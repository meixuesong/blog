<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[雪松]]></title>
  <link href="https://xuesong.tech/atom.xml" rel="self"/>
  <link href="https://xuesong.tech/"/>
  <updated>2024-03-13T16:07:43+08:00</updated>
  <id>https://xuesong.tech/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[关于我]]></title>
    <link href="https://xuesong.tech/guan-yu-wowo-shi-mei-xue-song.html"/>
    <updated>2023-10-23T00:18:20+08:00</updated>
    <id>https://xuesong.tech/guan-yu-wowo-shi-mei-xue-song.html</id>
    <content type="html"><![CDATA[
<p>我是梅雪松，是一名<strong>开发者</strong>，喜欢用代码来改变世界。我也是一名<strong>架构师</strong>，追求简单设计并致力架构的守护和演进，主持过多个大型遗留系统的现代化改造工作。我还是一名<strong>咨询师</strong>，帮助客户打造高绩效团队，提升团队在敏捷技术实践、DevOps等方面的技能，构建持续交付能力，并帮助团队应用领域驱动设计（DDD）、微服务等设计方法，提升软件质量。</p>
<p><img src="media/16979915004701/17100807020742.jpg" alt="" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[嵌入式系统的代码设计——实现灵活可扩展可替换的代码]]></title>
    <link href="https://xuesong.tech/17102610195467.html"/>
    <updated>2024-03-13T00:30:19+08:00</updated>
    <id>https://xuesong.tech/17102610195467.html</id>
    <content type="html"><![CDATA[
<p>书接<a href="https://xuesong.tech/17099718454993.html">上回</a>，码意浓在与大师深入探讨了架构设计后，便投身于全新嵌入式系统的开发工作。忙碌的日子里，他的内心却始终萦绕着一个未解的疑惑：新系统要如何通过统一的代码，灵活地应对全国各省的差异化需求？大师曾提及的“组件化”概念，这些组件要能够扩展、替换和编排，从而实现高度的可扩展性和可配置性。这些想法一直在他脑海中回响，但他却苦于无法将这一理念落地。于是，他决定再次拜访大师，寻求指点。</p>
<p><strong>码意浓</strong>：大师，我又来了。</p>
<p><strong>大师</strong>：哈哈，欢迎啊，小码。你无事不登三宝殿，是不是有什么新进展想和我分享？</p>
<span id="more"></span><!-- more -->
<p><strong>码意浓</strong>：嘿嘿，大师，最近项目进展得还算顺利，关于上次你提到的可扩展、可替换和可编排的架构设计，我还有一些具体实现上的问题想请教你。</p>
<p><strong>大师</strong>：你有什么想法？</p>
<p><strong>码意浓</strong>：能实现这样的扩展性，当然很好。但我的疑问是，我只在书里看到过这样的想法，从来没看哪个项目做到过。所以，这个问题一直困扰我。这种扩展性能实现吗？怎么实现呢？</p>
<p><strong>大师</strong>：很好，你这个问题问得很到位。要实现可扩展和可替换的设计，你一定要了解SOLID原则。</p>
<p><strong>码意浓</strong>：你是说 Bob 大叔提出的 SOLID 原则，也就是单一职责、开闭原则、里氏替换原则、接口隔离原则和依赖反转吗？</p>
<p><strong>大师</strong>：是的。这是 Bob 大叔将几个重要设计原则总结在一起，非常经典。</p>
<p><strong>码意浓</strong>：说实话，这些原则我都看过不止一遍。字我都认识，也好像都理解，但就是不知道怎么做到。</p>
<p><strong>大师</strong>：这些原则就像武功心法，是需要一定功底才能掌握的。但我觉得你是有基础的，你只是需要一根线把这些珍珠串起来，一旦成功串起来，就会有打通任督二脉的感觉。</p>
<p><strong>码意浓</strong>：怎么才能串起来呢？</p>
<p><strong>大师</strong>：我建议你先阅读这篇博客：<a href="https://xuesong.tech/16980614178175.html">写了这么多年代码，你真的了解SOLID吗？</a>，它详细解释了SOLID原则以及各原则之间的关系，而且还有示例代码。</p>
<p><strong>码意浓</strong>：好，我先学习一下。</p>
<p><strong>大师</strong>：正好我也要去冲杯咖啡，你也来一杯？</p>
<p><strong>码意浓</strong>：好的，谢谢大师！</p>
<p>稍候</p>
<p><strong>码意浓</strong>：我已经看了那篇博客，第一次真正体会到SOLID这几个原则之间的关系，确实有深度！但我还是有点迷茫，不知道如何在实际代码中应用这些原则。</p>
<p><strong>大师</strong>：没关系，我们可以从你的目标出发，你的目标是什么？</p>
<p><strong>码意浓</strong>：我的目标是实现组件能够扩展、替换，从而实现高度的可扩展性和可配置性。</p>
<p><strong>大师</strong>：那你觉得最能体现你目标的是哪个原则？</p>
<p><strong>码意浓</strong>：我想应该是开闭原则。开闭原则说的是对扩展开放，对修改闭合。意思是不用修改，而是直接扩展。</p>
<p><strong>大师</strong>：是的，你可以通过扩展，而不是修改来改变软件的行为。</p>
<p><strong>码意浓</strong>：虽然我认同这一点，但我觉得有点抽象。</p>
<p><strong>大师</strong>：比如一个 USB 端口可以扩展，你可以插入任何 USB 设备，不需要做任何修改来接受一个新的设备。因此，对于 USB 设备来讲，你这台有 USB 接口的电脑就是对扩展开放，对修改封闭的。</p>
<p><strong>码意浓</strong>：也就是说，当软件需要变化时，我们可以通过添加新的代码来实现新功能，而不是修改现有的代码。这就像是在搭积木，你可以不断地添加新的积木块来扩展结构，而不需要破坏已经搭好的部分。</p>
<p><strong>大师</strong>：是的。一方面就像你说的，可以添加新的代码来增加新功能。另一方面，也可以通过替换的方式来扩展。</p>
<p><strong>码意浓</strong>：怎么理解？</p>
<p><strong>大师</strong>：就像你的机械硬盘太慢了，你替换成固态硬盘。笔记本屏幕太小了，你外接一个大显示器。在编程中，我们可以通过抽象和继承来实现开闭原则。例如，你可以定义一个基类或接口，然后创建不同的子类或实现类来扩展功能。</p>
<p><strong>码意浓</strong>：对应到我这个系统里面，同样一种采集任务，但有的省份不一样，我就可以用一个新的实现来替换掉标准实现？这是不是策略模式？</p>
<p><strong>大师</strong>：替换的方式通常涉及到策略模式。策略模式是一种行为设计模式，它使你能在运行时改变对象的行为。你可以定义一系列算法或业务处理逻辑，并将每一个算法封装起来，使它们可以互相替换。这样，你就可以根据上下文的不同选择不同的策略来满足业务需要。</p>
<p>例如，假设你的系统需要根据不同的省份来处理订单支付方式。你可以定义一个支付策略的接口，并为每个省份实现具体的支付策略。然后，在运行时，你可以根据省份信息来选择相应的支付策略进行处理。</p>
<p><strong>码意浓</strong>：我懂了，这不就是 if/else 吗？我们老系统里就是 if/else 太多、太深导致很难维护。</p>
<p><strong>大师</strong>：你说得对，太多的 if/else 确实容易导致代码难以维护。但是，策略模式并不是简单地用 if/else 来判断。策略模式通常只在很少的地方进行 if/else 判断，甚至不需要判断。它通常是通过配置或者上下文信息来动态地选择策略。一旦选择了某个策略，后续的操作就与该策略相关，而不再与其他策略有关系。</p>
<p>例如，你可以将策略选择逻辑封装在一个工厂类或者配置文件中，这样就不需要在业务代码中频繁地使用if/else 来判断了。</p>
<p><strong>码意浓</strong>：原来如此，策略模式确实是一种更优雅的方式来处理业务变化。这就像是在玩乐高积木，可以方便地替换掉某一块积木。</p>
<p>但是，我想到一个问题，如果我们的系统非常大，要想替换掉某一部分功能，似乎还是一件挺难的事情。</p>
<p><strong>大师</strong>：你说得对，替换大型系统中的某一部分功能确实是一个挑战。这就需要你在设计系统时，尽量识别出大小合适的组件，并定义好它们之间的接口。这样，你就可以通过替换组件来实现功能的替换，而不需要修改整个系统。</p>
<p>这就涉及到了里氏替换原则。里氏替换原则告诉我们，子类必须能够替换其父类，并且替换后系统的行为要保持一致。这就要求我们在设计接口和类时，要遵循一定的规范，确保子类能够正确地替换父类。</p>
<p><strong>码意浓</strong>：里氏替换原则听起来很高级，但在C语言中如何实现呢？</p>
<p><strong>大师</strong>：在C语言中实现里氏替换原则，你需要更加注意接口的设计和组件的独立性。你可以通过函数指针类型来实现。这样，你就可以在运行时替换掉某个组件的实现，而不需要修改调用该组件的代码。</p>
<p><strong>码意浓</strong>：原来我在实际编程中偶尔也用到了这些方法，但没有去思考它们与SOLID原则的关系。不过，我在现实代码中发现，即使我定义了接口，仍然很难做到真正的复用或者替换。这是为什么呢？</p>
<p><strong>大师</strong>：这是一个很常见的问题。很多时候，我们的组件设计得太大了，接口也过于臃肿。这就导致我们的组件像鸡肋一样——有点用，但用起来不方便或者成本很高。</p>
<p>打个比方，如果你有一个工具箱，里面有各种各样的工具，包括扳手、螺丝刀、锤子等等。你还有一个便携式的多功能瑞士军刀，它里面也有小扳手、螺丝刀等工具。等你真正干活的时候，你会发现多功能瑞士军刀虽然也有用，但就是没有你工具箱里面的工具好用。</p>
<p><strong>码意浓</strong>：你是说，单一职责的扳手，比多功能瑞士军刀更好用？确实职责单一、固定大小的扳手会更好用一些。</p>
<p><strong>大师</strong>：同样的道理，如果你的组件接口过于复杂，包含了太多的功能，那么其他开发者在使用你的组件时就会感到困惑和不便。他们可能只需要用到其中的一部分功能，但却不得不面对整个复杂的接口。</p>
<p><strong>码意浓</strong>：是的，功能多了，意味着依赖多了，想单独利用某个功能或者扩展某个功能时变得困难了，学习成本也高了。那应该怎么解决呢？</p>
<p><strong>大师</strong>：所以你要考虑接口隔离原则。这个原则告诉我们，应该尽量将接口细化，每个接口只承担一种角色。这样，其他开发者在使用你的组件时，就可以只关注他们需要的接口，而不需要关心其他不相关的接口。</p>
<p>这其实也是单一职责原则的体现。每个组件或者接口都应该只有一个引起变化的原因。如果你发现你的接口承担了太多的职责，那么就应该考虑将它拆分成更小的接口。</p>
<p><strong>码意浓</strong>：我明白了，接口隔离原则确实可以帮助我们设计出更易于使用和复用的组件。我在阅读那篇博客时，发现以往我们都是站在服务端来定义接口，而不是向博客中提到的，应该站在消费者的角度定义接口。</p>
<p><strong>大师</strong>：是啊，如果你是房产商，最简单的办法是把所有房子都盖成一样的，这样成本最低了。但你肯定就卖不出去了，因为你没有站在消费者的角度去做设计。</p>
<p><strong>码意浓</strong>：嘿嘿，这个比较容易理解。只要站位正确就不容易犯错了。从现在开始，我们要从消费者的角度去定义单一职责的组件，它的接口是 Role Interface，这样的组件比较小，就很容易满足里氏替换原则，从而很容易扩展和替换，使我们能够满足开闭原则。</p>
<p><strong>大师</strong>：你的理解很到位！</p>
<p><strong>码意浓</strong>：那最后一个依赖倒置原则呢？它似乎更侧重于面向对象编程的思想。而我正在使用的是C语言，这是一种过程性语言。依赖倒置原则是否也适用于C语言呢？</p>
<p><strong>大师</strong>：当然适用。依赖倒置原则的核心思想是：要依赖于抽象，不要依赖于具体实现。这并不仅仅是面向对象编程的专利，它同样适用于过程性语言如C语言。</p>
<p><strong>码意浓</strong>：让我想想。这篇博客说依赖倒置原则其实是在指导如何实现接口隔离原则。如果我前面的组件接口是 Role Interface，那么它就是抽象接口，意味着说，不论是消费端还是生产端，依赖的都是这个抽象接口。</p>
<p><strong>大师</strong>：是的。</p>
<p><strong>码意浓</strong>：在 C 语言里，这个抽象接口通常是函数指针类型。所以我其实已经满足依赖倒置原则了。</p>
<p><strong>大师</strong>：没错。你可以定义一个函数指针类型作为抽象接口，然后在运行时传入具体的实现函数。这样，你的代码就依赖于这个抽象接口，而不是具体的实现函数。</p>
<p><strong>码意浓</strong>：依赖倒置原则看上去高深莫测，但其实理解后感觉也非常简单。</p>
<p><strong>大师</strong>：如果说你在架构师的修行路上，有很多层窗户纸要捅破的话，这就是非常非常重要的那层窗户纸。一旦你掌握了它，你就能轻松设计出松耦合的组件和架构，写出可测试的代码。</p>
<p><strong>码意浓</strong>：太谢谢大师了，真的有种打通任督二脉的感觉！</p>
<p><strong>大师</strong>：记住，实现 SOLID 原则是有成本的，高度可扩展的系统也是有成本的。你不可能在一开始就实现任意功能都可扩展、可替换。只有等你识别出变化点，然后再抽象出组件和接口。这样，你就可以让系统具有很好的扩展性。当然，这并不意味着你不能在一开始就设计好系统。相反，你应该尽量在设计阶段就考虑到可能的变化点，并提前规划好组件和接口。但是，随着项目的进展和需求的变化，你可能还需要不断地重构和演进代码。</p>
<p><strong>码意浓</strong>：我明白了，实现 SOLID 原则确实需要权衡成本和收益。我会尝试在我的项目中应用这些原则，并根据实际情况进行调整和优化。</p>
<p><strong>大师</strong>：好啊，等你的好消息！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[嵌入式系统的架构设计——事件驱动架构的应用]]></title>
    <link href="https://xuesong.tech/17099718454993.html"/>
    <updated>2024-03-09T16:10:45+08:00</updated>
    <id>https://xuesong.tech/17099718454993.html</id>
    <content type="html"><![CDATA[
<p>码意浓是一位软件开发人员，他最近心情不错，因为他将要负责一个关键的嵌入式系统软件开发。他决定拜访自己多年的老师，听听大师的意见。</p>
<p><strong>大师</strong>：码意浓，好久不见，看你气色不错，有什么新鲜事想聊聊吗？</p>
<p><strong>码意浓</strong>：嘿，大师，我正好有个新项目想请教您。我们打算开发一个新的嵌入式系统来替换那个已经服役快20年的老古董了。</p>
<p><strong>大师</strong>：哦，终于要更新换代了，这可是个大好事。那个老系统确实已经跟不上时代了，维护起来也是头疼得很。</p>
<p><strong>码意浓</strong>：是啊，说起来都是泪。不过我也有点担心，新系统的设计可不是件容易的事。</p>
<p><strong>大师</strong>：别担心，我们一步一步来。你给我讲讲这个新系统。</p>
<span id="more"></span><!-- more -->
<p><strong>码意浓</strong>：这个新系统主要是一个任务调度系统，它将在特定的嵌入式设备中运行，负责编排和执行各种任务。这些任务有的需要按计划执行，有的则是收到命令后立即执行。而且，这些任务都与网络IO有关，都需要去访问外部资源，获取数据后再进行加工处理。</p>
<p><strong>大师</strong>：听起来确实是个复杂的系统。那在设计上，你们打算采用什么样的架构风格呢？</p>
<p><strong>码意浓</strong>：这正是我头疼的地方。老系统采用的是多线程架构，虽然大家都很熟悉这种风格，但多线程带来的问题也不少，比如共享数据、死锁、问题复现困难以及调试难度大等。所以我在想，新系统是否应该继续采用多线程架构，还是有其他更好的选择？</p>
<p><strong>大师</strong>：多线程确实有其局限性。不过，你也可以考虑一下事件驱动的架构风格。事件驱动在很多场景下都能提供更高的效率和更好的可扩展性。</p>
<p><strong>码意浓</strong>：事件驱动？这听起来是个不错的选择。您能给我详细解释一下事件驱动的原理和优势吗？</p>
<p><strong>大师</strong>：当然。简单来说，事件驱动就是基于事件的触发来执行任务。我们做个简单的比喻。多线程就像是高级饭店，每个顾客（任务）都有一个服务员（线程）专门为他们服务。客人来了有服务员点餐，从客人坐下到完成点菜，这个服务员都在那里等待。也就是阻塞式I/O。而事件驱动则像自助服务，没有服务员帮你点餐，你自己扫码点餐。系统会自动通知后厨。等饭菜好了，系统又会通知你自己去取餐。</p>
<p><strong>码意浓</strong>：我明白了，事件驱动确实有很多优势。但是，如何实现事件驱动呢？有没有现成的模型可以参考？</p>
<p><strong>大师</strong>：实现事件驱动的关键在于设计一个高效的事件循环机制。在这个机制中，系统会不断地监听事件源，一旦有事件发生，就触发相应的处理函数。这样，任务的执行就不再依赖于线程的切换，而是由事件的触发来驱动。至于现成的模型，你可以参考一下Reactor模型，它是一种常见的事件驱动模型，已经在很多系统中得到了成功的应用。</p>
<p><strong>码意浓</strong>：听起来很高大上的样子。但是我这个系统似乎可以简单一些。这个系统运行在一个封装了MQTT的总线架构上，所以MQTT的消息可以作为事件。由这些事件可以驱动所有的任务执行过程。您觉得这样可行吗？</p>
<p><strong>大师</strong>：哈哈，看来你已经有了自己的想法。确实，如果你的系统已经运行在一个封装了MQTT的总线架构上，那么MQTT的消息作为事件驱动任务的执行是完全可行的。这样一来，你就可以利用MQTT的发布/订阅模式来实现任务的调度和执行了。不过，事件驱动+多线程的方案确实比老系统的方案更加复杂，可能会对系统的稳定性产生不利影响。因此，在实现时你需要格外注意线程安全和并发控制的问题。</p>
<p><strong>码意浓</strong>：您说得对。我也在担心这个问题。那么，有没有可能采用单线程来实现事件驱动呢？这样或许可以简化系统的复杂度。</p>
<p><strong>大师</strong>：单线程实现事件驱动？这确实是个大胆的想法。不过，在某些场景下，单线程确实可以实现高效的并发处理。比如Node.js就是一个典型的例子，它采用单线程异步I/O的模型，实现了高并发的处理能力。但是，这需要你的系统具备异步化的特点，所有的I/O操作都是非阻塞的，这样才能充分利用单线程的优势。</p>
<p><strong>码意浓</strong>：您说得没错。其实我们的系统已经具备了异步化的特点。异步调用的成本大概在10ms以内。作为边缘设备，我们的并发量并没有服务器那么高，所以10ms以内的成本是完全可以接受的。这样一来，性能应该不会成为问题吧？</p>
<p><strong>大师</strong>：哈哈，看来你已经考虑得很周到了。确实，如果异步调用的成本在可接受的范围内，那么单线程实现事件驱动是完全可行的。而且，事件驱动还能带来一个额外的好处，就是解耦。由于事件的触发和处理是分离的，所以你可以很方便地添加、删除或修改事件处理函数，而不会影响到其他部分的代码。这对于系统的可扩展性和可维护性都是非常有利的。</p>
<p><strong>码意浓</strong>：太好了！解耦确实是我们这个系统非常需要的一个特性。因为全国各省的需求是有差异的，新系统需要在一套系统上实现全国各省的需求。这确实是个很大的业务挑战。您有什么建议吗？</p>
<p><strong>大师</strong>：针对这个业务挑战，我建议你在设计系统时充分考虑关注点分离、单一职责、开闭原则以及Unix的机制与策略分离原则等设计原则。通过将系统划分为多个独立的组件，每个组件负责一个特定的功能或业务逻辑。如果这些组件能够被扩展、被替换、被编排，你可以实现高度的可扩展性和可配置性。这样，你就可以根据各省的具体需求来定制和扩展相应的组件了。同时，事件驱动的架构风格也能帮助你实现组件之间的解耦和通信。</p>
<p><strong>码意浓</strong>：您的建议非常中肯！回去后我会好好思考这些原则，并尝试将它们应用到我们的系统设计中。谢谢您！</p>
<p>码意浓回到家中，依然非常兴奋，脑中都在想事件驱动、单线程、可扩展、可替换、可编排！</p>
<p>这天晚上，他梦到了圆圆的月亮，月亮挂在天空，也映在地面上的多条河流中。</p>
<p><img src="media/17099718454993/river2.jpg" alt="river2" /></p>
<p>第二天，码意浓又来拜访大师。</p>
<p><strong>码意浓</strong>：大师，我又来了。经过昨天的讨论，我对新系统的设计有了更清晰的认识。我想跟您分享一下我的设想：这个任务调度系统，就像一个自然生态，有多条河流，每条河流都跑着任务，对应并行运行的任务流。在每条河流中，任务是串行流动（执行）的，而且是按优先级排序流动。您觉得这样的设计怎么样？</p>
<p><strong>大师</strong>：哈哈，你的设想很有创意！将任务调度系统比作河流，确实能够形象地描述任务的流动和执行过程。</p>
<p><strong>码意浓</strong>：是的。每个任务由多个原子任务组成。原子任务是最小的任务，不可拆分。原子任务可以被扩展或者替换，任务则可以对原子任务进行编排。这样就可以实现一套标准实现，然后各省的需求可以在这个基础上，实现扩展、或者替换掉某些原子任务，也可以对原子任务进行重新编排。最后形成一个原子任务库，根据各省需求将原子任务编排成各种任务，这些任务按不同的优先级运行在多条河流中。</p>
<p><strong>大师</strong>：原子能力和编排这个思路非常好，系统将具有强大的可扩展性。再加上事件驱动带来的解耦能力，它肯定能够满足各种需求差异！</p>
<p><strong>码意浓</strong>：大师的组件可扩展、可替换和可编排启发了我。有了这三个特性，我们的架构可以应对任何挑战。</p>
<p><strong>大师</strong>：很好！不过，我还有一个问题。如果任务正在执行时，突然来了一个更高优先级的任务，你应该怎么处理呢？</p>
<p><strong>码意浓</strong>：我的想法是，将原子任务作为最小的调度单位。当高优先级的任务到来时，如果当前原子任务还没有执行完，那么就让它继续执行完。然后，在当前原子任务执行完毕后，立即插入这个高优先级的任务进行执行。这样，原子任务既是设计的最小业务组件，也是运行时的最小业务组件。</p>
<p><strong>大师</strong>：嗯，你的处理方式很合理。将原子任务作为最小的调度单位确实是与你的业务特点匹配的，而且能够简化任务的管理和调度过程。另外，你的设计还考虑到了任务的优先级和插入时机的问题，这在实际应用中也是非常重要的。最后它们还提供了系统所需的扩展性，能够满足全国各省业务的差异化需求。而这些还是建立在单线程基础上，对开发调试来说方便太多了。总的来说，你的设计思路很清晰，也很有创意。我相信按照这样的设计去实现新系统的话，一定能够取得很好的效果！</p>
<p><strong>码意浓</strong>：谢谢您的肯定！有了您的指导和建议，我对新系统的设计更有信心了。我很期待把这个系统建好，为我们的产品打下坚实基础！</p>
<p><strong>大师</strong>：祝你成功！</p>
<p>当码意浓离开的时候，他的内心充满了激动，眼神中透露出无比的坚定。愿我们共同为他送上祝福！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[嵌入式系统的质量——如何一次把事情做对？]]></title>
    <link href="https://xuesong.tech/17048572291123.html"/>
    <updated>2024-01-10T11:27:09+08:00</updated>
    <id>https://xuesong.tech/17048572291123.html</id>
    <content type="html"><![CDATA[
<p>不知道你有没有注意到，走进各个企业，总能看到那么几句振奋人心的标语，其中“一次把事情做对”绝对是个高频词汇。以前每次看到，我都会想：这家企业也太教条了，都什么时代了。对失败这么零容忍，还怎么创新呢。这个时代的主旋律不是从错误中学习，快速响应、快速迭代吗。</p>
<p>然而最近一年的嵌入式领域经历，让我重新反思，“一次把事情做对”不仅是对工作效率的追求，更是对质量控制的严格要求。在嵌入式产品开发领域，这一理念的重要性尤为突出。</p>
<span id="more"></span><!-- more -->
<p>与Web系统相比，嵌入式产品有其独特性。它是软硬件的紧密结合体，不易升级，一旦发布，出问题的解决成本异常高昂，后果更为严重。所以“一次把事情做对”就是一个合理且必要的目标了。</p>
<p>但是怎么做到一次把事情做对呢？我们从 4 个原则来聊聊。</p>
<h2><a id="%E4%B8%8D%E5%81%9A%E5%B0%B1%E4%B8%8D%E9%94%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>不做就不错</h2>
<p>在生活中，我们常说“<strong>不做就不错</strong>”。在工作中，我也要把这个原则送给你，它仍然是真理。说白了就是：没代码，无bug。</p>
<p>我不是说让大家不干活，而是在没搞清楚需求之前，千万别急着动手。你想想，画画草图、写写文档总比直接写代码来得轻松吧？而且成本也低多了。如果错了大不了重画重写，可是写成了代码，那就叫 bug。</p>
<p>你要学会拒绝需求。需求来了，你得想想这需求有价值吗？合理吗？如果对方说不清楚价值，给不出理由，那你就应该拒绝。告诉他不要浪费你的时间和公司的金钱。</p>
<p>你得要求明确的需求。当业务方提出技术规划或者需求时，BA（需求分析师）就要分析清楚这个需求的细节，一句话的需求太模糊，没法干，开发者也要拒绝。这是你的权利。一旦你干了，出了 bug 那就是你的错。</p>
<p>但你可能要问了，有些需求在初期就是模糊的，只能在做的过程中慢慢摸索，那怎么办呢？</p>
<p>记住，不做就不错，不写代码就没 bug！你问问自己，需求是模糊的，可你的代码能模糊吗？你写个模糊的代码让大家看看。计算机只能分清0和1，根本就不会模糊处理。所以即使需求是模糊的，但你写不出模糊的代码。如果你写出了代码，必然是你把模糊的东西变成了确定的东西，那你大概率就写了个bug。</p>
<p>正确的做法是，需求必须明确，不能模糊。如果在产品初期，摸索阶段，那么BA应该提出假设，进行验证。提出<strong>假设</strong>后，需求就是明确的。我们假设是这种情况，代码就这么开发，先验证，不断迭代就能逐渐找到更好的答案。</p>
<p>这种通过假设来明确需求的方法叫<strong>试错</strong>，你拿着模糊需求写成不模糊的代码，那叫 bug，这两者的区别你自己体会一下。</p>
<h2><a id="%E5%B0%91%E5%81%9A%E5%B0%B1%E5%B0%91%E9%94%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>少做就少错</h2>
<p>现在我们把能拒绝的工作拒绝了，把模糊的需求明确了，剩下的就是不得不做的了。我要送你的第二个原则是，少做就少错。</p>
<p>怎么做到呢？千万别急着动手写代码，否则你很可能来回反复要走不少弯路才能做对。我给你个三步法，让你少走弯路、少写代码，少出错。</p>
<p>第一步，<strong>脑中做一遍</strong>。你先在脑海中预演整个实现过程，这类似于一种虚拟的模拟运行。你要想清楚每一步的输入输出是什么，处理过程是什么。这一步很重要，它能确保你真正理解了需求，并提前发现潜在的问题和难点。</p>
<p>第二步，<strong>纸上画一遍</strong>。把你脑中预演的过程在纸上画个草图。这个过程不仅有助于整理思路，还能帮助你和别人沟通讨论。记住，一定要画出来。有时候你以为你想清楚了，画出来你才发现没想清楚。</p>
<p>第三步，<strong>找人问一遍</strong>。经过前两步，你对需求理解透了，实现方案也想清楚了。这时候你要找人问一遍。这个人最好是个有经验的人。他能对你的方案提出建议，也能发现你没注意到的、可能对原来的功能有影响的地方。即使对方没有经验，你也要找人问一遍。因为在你讲的过程中，你自己就能发现一些问题。</p>
<p>经过这样三步的准备和验证之后，你就可以信心满满地开始编写代码了。这时你在面对复杂问题时会从容不迫，出错的概率也大大降低。</p>
<h2><a id="%E8%AE%A9%E6%9C%BA%E5%99%A8%E5%A4%9A%E5%B9%B2%E6%B4%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>让机器多干活</h2>
<p>前面铺垫那么多，你可能都觉得那不是好好工作，只有写代码才是真正工作。其实你写的代码是非常宝贵的东西。产品的价值都是靠你一行行代码实现的。前面的铺垫就是为了让你能真正写好代码。</p>
<p>现在你终于开心地写着代码了。你要思考的是自己怎么少干活，怎么让机器多干活。毕竟，不做就不错，少做就少错。</p>
<p>这里我们暂且不提让AI来帮你写代码。你想想你在开发过程中，哪些工作是可以交给机器来做的呢？</p>
<p>开发的工作可以分为三大块：看代码、写代码、调试验证。验证对你来说既无聊又耗时间。你打着断点，看着变量是不是你想要的值，逻辑跳转对不对。这样的工作不停地重复着，有时候一抬头发现周围人都走光了，一天很快就过去而你还没定位到问题。</p>
<p>验证这部分是最容易交给机器来做的。你完全可以写个验证代码（测试代码）来验证程序的输出对不对，是不是你想要的结果。这是个一劳永逸的方法。验证代码你只要写一遍，它就在那里，孜孜不倦一遍遍运行着。你完全可以放心交给它帮你完成验证的工作。再进一步，你甚至可以先写验证代码，再写业务代码，这就是极限编程中的测试驱动开发（TDD）。</p>
<p>机器还可以帮你干其它活，那些重复的活你都可以让它干。所以这第三个原则“让机器多干活”还有另一个名字：自动化一切能够自动化的工作。</p>
<p>比如你的软件的构建，部署，一切能够自动化的工作，都应该交给机器来做。因为人都是会犯错误的。</p>
<h2><a id="%E6%97%A9%E7%BA%A0%E9%94%99%E3%80%81%E5%B0%91%E6%B5%AA%E8%B4%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>早纠错、少浪费</h2>
<p>前面三个原则讲的都是尽量地少干活，但只要干了活，就可能出错。所以最后这个原则是“早纠错、少浪费”，怎么尽早地发现错误，减少浪费。</p>
<p>对于产品研发来说，最大的浪费是返工。因为功能做得不对返工，因为质量问题返工，这些都造成品牌受损，成本增加。</p>
<p>问题发现得越晚，成本越高。所以我们要通过一切手段尽早纠错。极限编程提供了一个很好的参考机制：</p>
<ul>
<li>分钟、小时级别的反馈：通过结对编程、自动化测试、流水线完成。</li>
<li>天级别的反馈：每日站会、每个需求的验收测试</li>
<li>周级别的反馈：每个迭代的showcase</li>
<li>月级别的反馈：版本发布后的反馈</li>
</ul>
<p><img src="media/17048572291123/17049699186194.jpg" alt="" /></p>
<p>如果我们能建立极限编程这样的从分钟到月级别的多维度反馈机制，我们就能够在早期阶段及时察觉问题、纠正错误，从而显著提高工作质量并减少不必要的浪费。</p>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>质量就是生命线！嵌入式产品由于其自身特点，追求“一次把事情做对”是每个研发人员的追求。通过文中介绍的四个原则和相应的实践，建立多维度的反馈机制，你就能够最大化实现质量的提升和资源的充分利用。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[嵌入式系统的团队设计——团队拓扑]]></title>
    <link href="https://xuesong.tech/17042360951377.html"/>
    <updated>2024-01-03T06:54:55+08:00</updated>
    <id>https://xuesong.tech/17042360951377.html</id>
    <content type="html"><![CDATA[
<p>小时候看古代小说，总觉得他们打仗用的阵法特别炫酷，比如一字长蛇阵，攻击到蛇头、蛇身或蛇尾时，瞬间就能卷、绞、咬。这些情节总是让我觉得又威风又神秘，兴奋不已。长大后明白了作为个体的士兵在组成部队后，通过阵法的运用，能产生出远超个体之和的力量。</p>
<p>在现代商业社会，面对激烈的商业竞争，你的团队如何排兵布阵呢？本文尝试探讨一下团队拓扑在嵌入式领域的应用。</p>
<span id="more"></span><!-- more -->
<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%A2%E9%98%9F%E6%8B%93%E6%89%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是团队拓扑</h2>
<p>河南省新密市出土了一套4500年前我国最早的《<a href="https://baike.baidu.com/item/%25E9%25A3%258E%25E5%2590%258E%25E5%2585%25AB%25E9%2598%25B5%25E5%2585%25B5%25E6%25B3%2595%25E5%259B%25BE/8798422">风后八阵兵法图</a>》，传说由黄帝与其大将风后研创。该图共九幅，一幅为八阵正图，其余八幅为阵势图，每幅图旁均有文字说明，介绍攻防要诀。黄帝靠着这个兵法图，“用经略，北清涿鹿，南平蚩尤，底定万国”，一统中原。</p>
<p><img src="media/17042360951377/17044191512320.jpg" alt="" /></p>
<p>你看，4500年前古人就开始用阵法来打仗。他们是非常讲究布阵的。布阵得法就能充分发挥军队的战斗力，克敌制胜。</p>
<p>现代商业组织如何布阵呢？我们知道有金字塔型和扁平型的组织结构。这些都属于静态的结构。但在今天这样一个快速变化的商业环境中，我们需要更加强调动态变化。</p>
<p>《高效能团队模式》介绍了团队拓扑(Team Topologies)，它是一种全新的架构，一种动态的过程。书中提出了一种将团队结构和组织设计与软件系统的架构相结合的方法。它强调了在不同组织层次上创建适应性强、高效协作的团队结构的重要性。</p>
<p>团队拓扑定义了四种类型的团队，以及它们之间的三种交互模式。</p>
<p><img src="media/17037302112727/17037303604321.jpg" alt="" /></p>
<p>这四种类型和三种模式表示什么意思呢？</p>
<p>我们以某个嵌入式领域的组织为例。它有多个产品中心，每个产品中心就是一个<strong>业务流团队</strong>，它最接近用户，负责一个产品、一项服务或者一组功能，能够独立交付用户价值。</p>
<p>作为业务流团队，产品中心持续面临交付压力。他们可能没有时间去研究和学习新技能，所以需要赋能团队的帮助。<strong>赋能团队</strong>由特定技术领域或产品领域的专家组成，他们在工具、实践、框架、技术栈等方面给出高质量的建议。这使得业务流团队不必付出太多努力就能获得能力提升。</p>
<p>这个产品中心的产品还涉及到一些复杂的预测算法，由一个专家小组负责，这个小组就是复杂子系统团队。<strong>复杂子系统团队</strong>负责构建和维护系统中严重依赖专业领域知识的子系统。这类业务非常复杂，需要具备特定能力的专家。</p>
<p>产品中心基于公司的产品平台，根据特定行业的客户需求做二次开发。这套产品平台由一个平台团队负责。<strong>平台团队</strong>的目标是使业务流团队能够以高度自治的方式交付工作。平台团队提供的内部服务使得业务流团队无须开发底层服务，降低了认知负荷。</p>
<p>熟悉完这四类团队，我们再看看三种交互方式。</p>
<p>产品中心刚成立时，对产品平台不熟悉，需要平台小组手把手教，一起工作。这时候他们的交互方式是<strong>协作</strong>（一起紧密地工作）。</p>
<p>产品中心将以敏捷的方式交付产品，因此聘请了外部顾问团队做敏捷赋能工作，以优化研发管理并提升技术实践能力。顾问团队提供的是指导和赋能，而不是直接参与具体交付工作，因此他们之间的交互方式就是<strong>促进</strong>。</p>
<p>产品中心还需要其它部门的协助，例如需要物资部提供元器件的采购服务。这时候物资部以<strong>服务</strong>的方式提供能力给产品中心。服务有清晰的边界，不需要了解太多上下文，可以尽量减少协作。</p>
<h2><a id="%E5%9B%A2%E9%98%9F%E6%8B%93%E6%89%91%E5%9C%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>团队拓扑在嵌入式领域的应用</h2>
<p>团队拓扑的价值在于，它能帮助我们以动态的视角来排兵布阵。我们在<a href="https://xuesong.tech/17037655703316.html">嵌入式系统的团队设计——团队优先</a> 中提到，要采用“团队优先”的原则，降低团队认知负荷。我们来看看如何利用团队拓扑进行排兵布阵。</p>
<h3><a id="%E4%BB%8E%E4%BB%B7%E5%80%BC%E6%B5%81%E5%8F%91%E6%8E%98%E4%B8%9A%E5%8A%A1%E8%83%BD%E5%8A%9B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>从价值流发掘业务能力</h3>
<p>价值流是指在整个产品开发过程中，从需求到最终用户获得价值的全部过程。通过价值流分析，可以深入了解整个业务流程，识别潜在的业务能力需求。</p>
<p>可以通过生产路径图（Path to Product）可视化从需求到最终交付的整个价值流。在生产路径图中，每个阶段都有其特定的目标、活动以及所需的业务能力。业务能力是组织实现其目标所需的技术和业务的组合，不同的业务能力在不同的阶段发挥着关键作用。例如，需求分析阶段需要强大的业务分析和知识转化能力。在设计阶段，需要在硬件、电气、结构和软件等领域的专业能力。</p>
<h3><a id="%E4%BB%8E%E4%B8%9A%E5%8A%A1%E8%83%BD%E5%8A%9B%E8%AF%86%E5%88%AB%E4%B8%9A%E5%8A%A1%E6%B5%81%E5%9B%A2%E9%98%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>从业务能力识别业务流团队</h3>
<p>从业务能力中找到核心能力，核心能力离客户最近，要能够独立贡献客户价值。这些是业务流团队需要具备的能力，通过核心能力识别找到业务流团队。</p>
<p>以一家嵌入式领域的公司业务举例来说，其价值流是以行业标准为基础，满足各地区的差异化需求，完成产品供货是其价值流。其中产品的设计、软件研发是其核心能力。而标准制定、批量生产不是其核心能力。这家公司将产品中心作为业务流团队，产品中心需要拥有这些核心能力。</p>
<h3><a id="%E9%80%86%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B%E8%AE%BE%E8%AE%A1%E4%B8%9A%E5%8A%A1%E6%B5%81%E5%9B%A2%E9%98%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>逆康威定律设计业务流团队</h3>
<p>产品中心作为业务流团队，可能仍然规模太大，需要进行拆分。康威定律揭示了组织结构对产品结构的深远影响，拆分团队需要考虑康威定律。</p>
<p>康威定律（Conway's Law）是由计算机科学家梅尔·康威（Melvin Conway）提出的原则，它表明组织结构的设计会影响到所生产的系统的设计：</p>
<blockquote>
<p>设计系统的组织由于受到约束，这些设计往往是组织内部沟通结构的副本。</p>
</blockquote>
<p>也就是说，如果组织结构与系统架构不一致，最终组织结构会胜出，系统架构将会与组织结构匹配。例如有四个小组合作开发一个编译器，那么你将得到一款具有四个步骤的编译器。</p>
<p>逆康威定律是对康威定律的一种反思，由Thoughtworks的技术总监James Lewis提出：团队结构必须与所需的软件架构或者产生非预期设计的风险相匹配。</p>
<p>逆康威定律的目标是使组织更适应系统的需求。例如编译器架构设计了4个模块，我们可以考虑由4个团队开发这个编译器。这有助于促进系统的灵活性和创新，以适应不断变化的业务和技术环境。</p>
<p>设计业务流团队时，除了逆康威定律的指导，还要考虑团队规模。参考<a href="https://xuesong.tech/17037655703316.html">嵌入式系统的团队设计——团队优先</a> 中提到的5-9人团队规模，以及设计系统边界，以降低团队认知负荷。</p>
<h3><a id="%E5%A2%9E%E5%BC%BA%E4%B8%9A%E5%8A%A1%E6%B5%81%E5%9B%A2%E9%98%9F%E7%9A%84%E8%83%BD%E5%8A%9B%EF%BC%8C%E6%B6%88%E9%99%A4%E7%9F%AD%E6%9D%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>增强业务流团队的能力，消除短板</h3>
<p>根据价值流各阶段的目标和能力要求，识别出业务流团队的能力短板和瓶颈，通过各种手段为业务流团队高效、高质量地交付产品提供系统性支撑。</p>
<p>如果是技术过于复杂，可以建立复杂子系统团队，封装技术复杂性。例如某个预测算法，可以由内部资深专家，或者与大学等研究机构合作，形成专家团队。</p>
<p>如果是某些能力不足，可以在公司内部或者寻找外部资源，组成赋能团队，引入新的方法、实践和工具，提升团队的认知能力和工具升级。例如在质量内建、持续交付、项目管理等方面引入外部顾问团队。</p>
<p>如果发现产品已经逐渐成熟，可以平台化，可以建立平台团队，打造产品平台，以提升团队的响应力。这一点很多企业都在做，需要注意的是，平台应该与产品紧密结合。例如平台来源于产品，并反过来成就产品。</p>
<h3><a id="%E6%8C%81%E7%BB%AD%E8%BF%9B%E5%8C%96%E5%9B%A2%E9%98%9F%E6%8B%93%E6%89%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>持续进化团队拓扑</h3>
<p>团队拓扑需要与时俱进，这不仅体现在结构上，也体现在交互方式上。</p>
<p>例如在产品探索阶段，业务专家、硬件、软件和结构团队需要高度协作，它们的边界是重叠的，甚至可能成立多功能团队，由不同角色人员组成一个创新小团队。这时候团队间的交互模式是协作。当产品成型后，团队间交互可能由协作变为服务。例如结构团队只根据产品中心的需求做结构修改服务。</p>
<p><img src="media/17042360951377/17048549018031.jpg" alt="" /></p>
<p>产品平台也存在类似的情况。当一个业务流团队想基于产品平台快速定制出一个新产品时，由于这个业务流团队是第一次使用产品平台，需要手把手教。这时候可以采用<strong>协作</strong>方式，由产品平台团队派人与业务流团队一起密切工作。当业务流团队基本熟悉了产品平台后，可以采用<strong>赋能</strong>的方式，按需指导，但不参与业务开发。当业务流团队足够成熟后，可以采用<strong>服务</strong>方式，通过团队API提供支持，例如完整的官方平台文档。</p>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>团队拓扑不仅是一种组织设计方法，更是一种思考动态变化的商业环境下如何最优化团队结构的理念。以业务流团队为中心，以团队优先为原则，通过赋能团队、复杂子系统团队和平台团队，降低团队认知负荷，并灵活运用三种交互模式，组织能够更好地应对未知挑战，提高整体效能。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[嵌入式系统的团队设计——团队优先]]></title>
    <link href="https://xuesong.tech/17037655703316.html"/>
    <updated>2023-12-28T20:12:50+08:00</updated>
    <id>https://xuesong.tech/17037655703316.html</id>
    <content type="html"><![CDATA[
<p>组织中所有的问题都可以最后归结为人的问题。很多时候我们期望流程和工具能够解决这些问题，然而如果忽视了团队中个体的需求、动机和互动方式，那么再正确的流程和再好的工具也无济于事。因为流程和工具无法发现人、培养人、激发人。</p>
<p>真正的团队效能来源于团队之间以及成员之间的协同合作、有效沟通和共同目标。因此，在构建和优化团队时，我们需要将关注点放在团队本身，坚持“团队优先”的原则。</p>
<span id="more"></span><!-- more -->
<h2><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%81%9A%E9%9B%86%E4%BA%8E%E5%9B%A2%E9%98%9F%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么要聚集于团队？</h2>
<p>嵌入式系统涉及的技术领域广泛且复杂，包括硬件、固件、驱动、软件等。一个团队中的成员可能各自专长于某一技术方向，但一个有凝聚力的团队能够充分利用每个成员的专长，同时弥补彼此的短板，从而在整体上具备更全面的技术能力。因此，一个有凝聚力的团队的表现要远远超出个人的集合。</p>
<p>有些嵌入式团队依赖于某几个技术骨干，他们能力很强、效率很高。但缺乏人才梯队的团队并不是一个健康的状态。几年前，一则关于10倍工程师能力的推文在社交媒体上引发了广泛的讨论。投资人Shekhar Kirani在Twitter上提出了这一观点：“有些工程师能以一当十，创业者如果有幸有这些人加盟，那么成功率就能够大幅提升。”虽然有些人赞同这一观点，但更多的人则是以讽刺的方式表达了不同的看法。</p>
<p>Thoughtworks技术雷达认为与10倍工程师相比，更应该关注10倍团队：</p>
<blockquote>
<p>在过去的几个月中，10倍工程师一词受到了密切的关注。一个广泛传播的推文讨论在实质上建议公司应原谅反社会和破坏性的行为，以留住被认为个人产出巨大的工程师。幸运的是，许多人在社交媒体上都嘲笑了这个概念，但是“明星开发者”的刻板印象仍然普遍存在。根据我们的经验，伟大的工程师不是因为个人产出而是因为能在优秀的团队中合作而诞生。打造一支混合不同经验和背景，但成员才华横溢的团队，并为团队合作、学习和持续改进提供良好的助力，这会是更行之有效的方式。这些10倍团队行动起来更快，弹性也更强——而无需屈从错误的行为。</p>
</blockquote>
<p>《敏捷革命》中也提到同样的观点。耶鲁大学的乔尔·斯波尔斯基（Joel Spolsky）教授把学生的成绩和花费的时间做了对比。发现最快的学生和其他同学的速度相比是10:1。最快的学生是其他同学的10倍。然而，一项涉及3800个项目的研究发现，团队之间的差别比个人之间的差别大得多。最好的团队可以在1周内完成任务，但最慢的团队不是花费10周，而是花了2000周。这就是最差团队和最好团队的差别。所以如果你聚集于团队能力，就算是让最差的团队达到中等水平，效率也会有惊人的提升。</p>
<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%A2%E9%98%9F%E4%BC%98%E5%85%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是团队优先？</h2>
<p>团队优先意味着组织不仅鼓励团队追求远大的目标，还给予其充分的自主性。这样的团队能够自我组织、自我管理，他们有能力决定如何工作并获得所需的授权。</p>
<p>团队优先还意味着要充分考虑团队的认知负载、协作方式、沟通成本和人员能力等。只有把每个人看作生态中的一份子，产生内驱力，提供机会，提升能力，才能真正激发团队的潜力，推动团队走向卓越。</p>
<p>在团队内部，团队成员也要有团队优先的意识，意味着团队成员将团队需求置于个人需求之上，能够：</p>
<ul>
<li>聚焦于团队目标。</li>
<li>保证讨论和调研事项走上正轨。</li>
<li>在开始新工作之前帮助其他成员解决阻塞事项。</li>
<li>辅导新团队成员和缺乏经验的成员。</li>
<li>高效参加团队活动（周会、站会等）。</li>
<li>避免陷入“谁赢谁输”的争论，与此相反，乐于探索新的选项。</li>
</ul>
<p>要做到团队优先，可以从团队规模、团队生命周期、责任心、限定边界、降低认知负载和共享知识入手。</p>
<h2><a id="%E5%B0%8F%E5%9B%A2%E9%98%9F%E6%9B%B4%E5%AE%B9%E6%98%93%E5%BB%BA%E7%AB%8B%E4%BF%A1%E4%BB%BB%E5%92%8C%E7%B4%A7%E5%AF%86%E7%9A%84%E5%90%88%E4%BD%9C%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小团队更容易建立信任和紧密的合作关系</h2>
<p>有研究发现，高度信任的团队是驱动创新和实验的源泉。如果信任缺失，或者由于组织变大而不断降低，交付的速度和安全将受到影响。</p>
<p>团队规模对信任度有直接影响。亚马逊著名的“两张比萨”团队理念强调了小团队的效率与协作优势，而Scrum框架所推荐的团队人数也倾向于5-9人。这些数字背后的原理都可以用邓巴数字来描述。邓巴发现15是一个人可以信任人数的极限，而其中只有5个人能获得深入了解和信任。一旦人数超过9人，信任就会开始崩塌。</p>
<p>团队人数的增加，也会增加沟通成本。你可以简单测算一下人数与沟通渠道的关系。只要把团队人数乘以“团队人数减1”，然后再除以2就行了。对人数为n的团队，它的沟通渠道数量=n(n-1)/2。比如，如果团队有5个人，那么团队的沟通渠道是10条；如果有9个人，沟通渠道是36条；而10个人的沟通渠道会有45条。过多的沟通渠道将超过了人脑的承受能力，我们根本不知道别人正在做什么。沟通成本也急剧增加，例如简单的会议可能从几分钟增加到数小时。</p>
<h2><a id="%E5%BB%BA%E7%AB%8B%E9%95%BF%E6%9C%9F%E7%A8%B3%E5%AE%9A%E7%9A%84%E5%9B%A2%E9%98%9F%E4%BB%A5%E8%BE%BE%E5%88%B0%E9%AB%98%E6%95%88%E8%83%BD%E7%8A%B6%E6%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>建立长期稳定的团队以达到高效能状态</h2>
<p>除了团队规模，高信任度的团队还取决于团队的生命周期。</p>
<p>团队需要花时间磨合以形成生产力。Tuckman模型描述了团队在四个阶段上的表现：</p>
<ol>
<li>组建期：团队刚刚建立。</li>
<li>激荡期：解决最初的个性和工作方式上的差异。</li>
<li>规范期：共同演进标准工作方式。</li>
<li>执行期：达到高效能状态。</li>
</ol>
<p>在高度信任的组织中，几个月换一个团队可能不是大问题。例如在Thoughtworks，团队通常按项目临时组建。由于大家具有相同的价值观和做事方法，所以能够很快形成生产力。但在大多数传统组织，人们需要3个月，甚至更长时间的磨合来形成生产力。</p>
<p>因此，组建长期的产品团队始终优于短期的项目团队。项目是临时的，具有明确开始时间和结束时间，生命周期通常比较短。而产品是长期存在的。如果6个月的项目结束就调换团队，并不是一个好选择。反而保持稳定的产品团队能够维持团队的凝聚力和生产力。</p>
<p>另一种方法是Allan Kelly在他的《Project Myopia》中提到的，让“工作流向团队”。团队应该保持稳定，而非一成不变，仅在必要的时候进行偶尔的调整。</p>
<h2><a id="%E5%9B%A2%E9%98%9F%E4%B8%BA%E4%BA%A7%E5%93%81%E8%B4%9F%E8%B4%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>团队为产品负责</h2>
<p>一个为产品负责的团队，其核心优势在于集体的力量和协作的精神，而不是依赖于单一的个体。这样的团队通过共同的目标和责任，将个体的能力凝聚成强大的整体，从而能够更好地应对挑战和实现卓越的成果。团队成员彼此信任、互相支持，在共同成长中不断提升团队的战斗力。这种团队文化不仅有助于产品的成功，还能为企业和组织创造持久的价值。</p>
<p>每个产品都应该拥有一个唯一的负责团队，做到责任明确、不分散。这种安排避免了多个团队之间可能出现的责任推诿或工作重叠，从而提高了工作效率和产品质量。当问题出现时，该团队能迅速做出反应并找到解决方案，因为他们对自己的产品了如指掌，也对其成功负有全部责任。这种责任制促使团队成员更加专注、投入，以确保产品的成功和满足市场需求。通过明确的责任划分，企业能够更有效地管理资源，推动产品不断创新和进步。</p>
<p>团队应该拥有自主性。这意味着在既定的边界内，团队能够自主决策、自我组织，从而灵活应对各种挑战，高效推动任务的完成。这种自主性不仅提升了团队的责任感和积极性，也促进了成员之间的协作与创新。</p>
<h2><a id="%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F%E8%BE%B9%E7%95%8C%EF%BC%8C%E9%99%8D%E4%BD%8E%E5%9B%A2%E9%98%9F%E8%AE%A4%E7%9F%A5%E8%B4%9F%E8%8D%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设计系统边界，降低团队认知负荷</h2>
<p>如果一个团队的认知负荷过高，例如任务过多、负责的系统复杂度过高，团队成员可能会面临过大的信息处理和决策压力，降低了自主性。这会导致团队工作效率下降，成员难以集中精力完成任务，甚至可能引发工作质量下降和错误率增加。这种连锁反应可能会导致团队效能走入恶性循环。因此，合理管理团队的认知负荷对于提高团队效率和确保工作质量至关重要。</p>
<p>采用团队优先原则时，团队的职责应该与团队的认知负荷相匹配。这意味着要限制团队负责系统的大小和复杂度。</p>
<p>可以将系统按领域划分，每个领域再划分为简单、复杂、非常复杂等级别。一个团队可以负责一个复杂领域或者多个简单的领域。对于非常复杂的领域应该由专门的专家团队负责或者进一步拆分成多个领域。</p>
<h2><a id="%E9%9A%90%E6%80%A7%E7%9F%A5%E8%AF%86%E6%98%BE%E5%BC%8F%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>隐性知识显式化</h2>
<p>在团队中，隐性知识的显式化对于促进团队能力成长至关重要。隐性知识是指难以用言语表达的技能、经验，这种知识难以传承和分享，限制了团队能力的提升。</p>
<p>我们在一些嵌入式团队发现，产品的需求非常复杂，但由于历史原因，没有完整的文档，只有个别骨干掌握了较完整的信息。这些存在于骨干大脑中的隐性知识如果不显式化出来，就不利于团队的能力成长。</p>
<p>通过将隐性知识显式化，即将其转化为明确、可传播的知识，例如分享经验、将其文档化，建立知识库，团队成员可以更好地理解和掌握这些知识，从而更好地积累和利用经验，提高工作效率和质量。同时，显式化也有助于增强团队的协同效应，促进成员之间的相互学习和共同成长。</p>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>在嵌入式系统领域，由于涉及的技术领域更加广泛且复杂，包括硬件、固件、驱动、软件等，如何打造高效能团队，团队设计至关重要。本文强调了采用“团队优先”的原则，提升10倍个人能力很难，但提升10倍团队能力是完全可能的。通过关注团队规模、建立长期稳定团队、限制团队的系统边界、降低团队认知负荷，以及将隐性知识显式化逐步，团队可以更好地应对技术挑战，提高工作效率，最终推动整个团队走向卓越。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[嵌入式系统的需求管理——如何将交付效率提升一倍？]]></title>
    <link href="https://xuesong.tech/17035756228983.html"/>
    <updated>2023-12-26T15:27:02+08:00</updated>
    <id>https://xuesong.tech/17035756228983.html</id>
    <content type="html"><![CDATA[
<p>在以往，嵌入式系统开发往往是单兵作战，依赖于个体能力，详细的需求文档并不被视为必要条件。然而，随着嵌入式系统的复杂度不断提高，团队协作变得至关重要。这就离不开知识的传递和消费，因此需求管理在嵌入式系统中的重要性日益凸显，它不仅关乎业务实现，更影响到团队的沟通和项目顺利进行。</p>
<p>最近，我们在一项嵌入式项目中探索了不同的需求描述方法，从传统的需求规格说明书到敏捷的用户故事，再到我们最终采用的系统用例。这一方法极大地提升了团队的开发效率，本文将分享我们的经验和思考。</p>
<span id="more"></span><!-- more -->
<h2><a id="%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9C%80%E6%B1%82%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8F%8F%E8%BF%B0%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>嵌入式系统的需求应该如何描述？</h2>
<p>今年，我们有幸参与了一项极富挑战性的嵌入式项目。我们首先面临的问题是如何将客户的想法转化为可供开发的需求文档。</p>
<p>最初客户采用了传统的需求规格说明书的形式。然而我们很快发现，这种通用的模板并不能很好地满足我们的需求。规格说明书的冗长和细节繁多，既增加了编写的工作量，在该详细说明的地方又没说清楚。</p>
<p>作为敏捷软件开发的实践者，我们迅速转向使用用户故事管理需求，用户故事（User Story）是从用户的角度来描述用户渴望得到的功能。它包括三个要素：角色、活动和商业价值。但遗憾的是，用户故事并不适用于我们的嵌入式场景。</p>
<p>首先嵌入式系统中的角色非常单一，并不存在多个角色。另外，用户故事INVEST原则的“可协商性”和“有价值”在这里并不重要。因为嵌入式产品通常完成确定的功能，其价值也是作为一个整体来体现。在我们这个项目中，它完成的是一些标准协议和明确的交互，不存在可协商性。而价值更侧重于整个系统提供完整业务价值，单个具体功能的价值体现非常有限。最后，用户故事通常不涉及详细的实现步骤，更多是围绕价值和验收条件。但在嵌入式系统中，恰恰相反，验收条件可能很简单，但实现过程却非常复杂。如果需求文档缺少了过程的描述，则起不到需求的作用。</p>
<p>那么嵌入式系统究竟应该怎么描述需求呢？有没有更理想的方法？</p>
<p>这使我想起多年前阅读过的经典著作<a href="https://book.douban.com/subject/1233316/">《编写有效用例》</a>，这是一本与Jez Humble的持续交付一样获得Jolt大奖的经典书籍。</p>
<p>能否将用例​用于嵌入式系统的需求管理呢？​</p>
<h2><a id="%E7%B3%BB%E7%BB%9F%E7%94%A8%E4%BE%8B%E5%9C%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A2%86%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>系统用例在嵌入式领域中的应用</h2>
<blockquote>
<p>用例是系统中各个干系人（stakeholder）就系统行为所达成的契约。用例描述了在不同条件下，系统对某一干系人的请求做出响应时发生的系统行为。</p>
</blockquote>
<p>我们采用了一个简化的系统用例模板来描述需求，一个用例只需要包括三部分：概述、基本路径和扩展路径。我们来看一个示例：</p>
<pre><code class="language-plain_text">一、概述

XX方案一般由主站发送报文，由TM将报文下发，并将设备返回的报文保存到A中心。......

二、基本路径

1 TM根据任务设置，周期性执行XX方案
2 TM根据任务的方案ID，从A中心查询方案
3 A中心返回方案，方案中有“内容集”，结构见附录。
4 TM对“内容集”的“内容”进行循环，执行后续步骤。
5 TM根据通信地址，找到设备档案。
6 TM根据设备档案，确定是通过串口还是载波下发报文。
7 TM通过串口/载波发送方案报文集的一条报文。
8 串口/载波App返回ACK成功。
9 串口/载波App返回设备的报文。
10 TM将设备的原始报文保存到A中心，以记录型数据保存。
...

三、扩展路径

5a TM根据通信地址，未找到设备档案。
5a1 TM结束当前业务处理。

8a 串口/载波App返回ACK超时
8a1 TM重试一次，如果仍然超时则结束业务处理

8b 串口/载波App返回ACK否认
8b1 TM结束当前业务处理。
</code></pre>
<p>基本路径是主成功场景，通常是一切顺利的情况下，系统的处理步骤。扩展路径表示备选流，描述了各种分支和异常场景的处理。例如8a就是第8步的一个分支，8a1 表示这个分支的第1步。8b表示第8步的另一个分支，以此类推。</p>
<p>在嵌入式系统中，一个功能通常由若干系统组件共同完成。它可能是由人工触发或者物联设备、系统内置模块等触发，然后系统的不同组件互相协同，通过接口进行交互，完成特定功能。</p>
<p>通过系统用例，我们用不到20行文字就把这个需求描述清楚了。这样的文档具有开发和测试人员所需要的详细信息，同时编写起来也比较简单，不用花很多时间。</p>
<h2><a id="%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A2%86%E5%9F%9F%E9%87%87%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%94%A8%E4%BE%8B%E7%9A%84%E4%BC%98%E5%8A%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>嵌入式领域采用系统用例的优势</h2>
<p>我们在实践中发现，系统用例特别适合于嵌入式系统。</p>
<p><strong>需求非常清晰</strong></p>
<p>嵌入式系统通常只有很少的UI交互，有些甚至完全没有UI交互。如何描述清楚需求，是一个很大的挑战。</p>
<p>与传统需求规格说明书中的大段落，没有章法的描述相比，系统用例可以清晰地描述每一个步骤的系统行为。每一步都使用简单的语法，而且都很明确，谁做什么事情，或者谁做出什么响应。主语、谓语动词、直接宾语等，这些构成了一个非常简洁、清晰的需求。</p>
<p><strong>提升开发效率</strong></p>
<p>开发人员的时间通常花在想清楚这个需求怎么做、动手开发、调试和测试，以及返工上。而测试人员的时间通常花在理解这是个啥需求，我要怎么测上。在这些方面系统用例都能够大幅提升效率。</p>
<p>系统用例能够提供详细、准确和简洁的需求，为团队提供了明确的方向，避免因为误解或遗漏需求而导致的设计和代码修改。这不仅可以节省开发时间，更重要的是减少了返工的时间。毕竟返工是最大的浪费。</p>
<p>系统用例降低了沟通成本，使团队成员能够快速理解需求并高效地分工合作。BA、Dev和QA可以基于同一份文档高效合作。</p>
<p>对于使用TDD开发的Dev来说还有一个额外的帮助，任务分解（Tasking）变得更加简单了。因为系统用例的每一步都是一个Task。</p>
<p><strong>交付高质量产品</strong></p>
<p>嵌入式系统对于质量有着更高的诉求，有些甚至是工业级产品要求。做一个能工作的产品很容易，但要做一个工业级的产品，要付出十倍、百倍的工作量。如何提升产品的质量？以往的经验告诉我们，产品质量取决于对异常情况的处理。</p>
<p>系统用例通过扩展路径来描述各种备选流和异常分支。在分析需求的过程中，需求分析师通过自问“这一步还会出现别的情况吗？”，可以发现很多程序需要应对的场景。例如，对方超时未响应，对方返回错帧等等。</p>
<p>开发人员可以跟随系统用例的每一步，采用TDD，开发出高质量的代码和安全防护网。</p>
<p>测试人员也非常容易根据系统用例来设计针对边界值、特殊场景的测试用例。甚至提前发现需求遗漏的场景，这也是测试左移的价值。</p>
<p>所以这些都能够帮助团队将质量内建在每个交付过程中。</p>
<h2><a id="%E6%A1%88%E4%BE%8B%EF%BC%9A%E7%B3%BB%E7%BB%9F%E7%94%A8%E4%BE%8B%E5%B8%AE%E5%8A%A9%E6%88%91%E4%BB%AC%E6%8F%90%E5%8D%87%E4%B8%80%E5%80%8D%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>案例：系统用例帮助我们提升一倍开发效率</h2>
<p>我们团队最近交付了一个嵌入式系统软件，这个软件运行于一个终端产品中，完成边缘计算任务。产品具有非常高的稳定性要求，需要在各种恶劣环境下，7*24小时长年持续稳定运行。</p>
<p><img src="media/17035756228983/%E7%BB%88%E7%AB%AF%E7%94%B5%E8%A1%A8.jpg" alt="" /></p>
<p>在项目早期没有系统用例的时候，因为团队不熟悉业务，对粗粒度的需求文档理解起来非常困难，即使经过多轮沟通，也仍然会有误解或遗漏。大家花费了大量时间去理解业务，代码也经常出现返工。交付效率一直提不上去，质量也不高。</p>
<p>在采用系统用例描述需求后，这种局面得到了彻底改善。即使团队不熟悉业务，也能够按照需求文档的描述完成功能开发。开发效率大幅提升，同样规模的功能，现在只需要一半的时间。其中最明显的区别在于开发人员在理解我要干什么这件事情的认知负担明显降低了，返工明显减少了，而且质量还提高了。</p>
<p>系统用例作为一种描述需求的方法，其简洁、准确的特点有助于形成高质量的需求文档。这些文档为开发过程提供明确的指导，而且会积累成为知识库。这个知识库不仅是组织的核心资产，还能助力新人快速融入项目，提升团队整体能力。</p>
<h2><a id="%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结与展望</h2>
<p>本文探讨了嵌入式系统的需求管理，并分享了在一个具有挑战性的嵌入式项目中所取得的经验。通过对需求描述方式的多次尝试，最终确定了在嵌入式场景下更为适用的需求管理方法——系统用例。通过系统用例，团队成功地提高了开发效率，使得交付过程更为流畅。</p>
<p>展望未来，我们期待继续在嵌入式系统的开发中探索更加精细、高效的需求管理方法。通过不断总结经验，优化流程，我们期待在需求管理领域寻找更多创新的方法，以适应未来嵌入式系统的复杂性挑战。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么又建了个博客？]]></title>
    <link href="https://xuesong.tech/wei-shen-me-you-jian-le-ge-bo.html"/>
    <updated>2023-10-23T00:18:20+08:00</updated>
    <id>https://xuesong.tech/wei-shen-me-you-jian-le-ge-bo.html</id>
    <content type="html"><![CDATA[
<p>我曾经建过多个博客，有的坚持时间长一些，有的则是享受建工具的过程，却没有写博客。这次又建了个博客，原因是最近有了一些想法。</p>
<p>首先是复利的思想。虽然早就知道复利，但最近在一本书中读到这样一句话：</p>
<blockquote>
<p>生活中所有的回报，无论是财富、人际关系，还是知识，都来自复利。</p>
</blockquote>
<p>这个“<strong>所有的回报</strong>”，还是让我很有感触。细想确实如此，知识、声誉都存在复利效应。博客写在那里，就是知识的积累，不仅对自己有帮助，也能分享给需要的人。通过写作也能不断积累自己的声誉，逐渐产生杠杆作用。</p>
<p>其次是按照费曼学习法，将自己所学输出成文字，加深对知识的理解，将知识内化到自己的思想中。</p>
<p>最后是自省。如果博客写的少，没内容可写，某种程度上说明自己没有进步、没有积累、没有沉淀。这时候需要自省一下，我想要什么？我要到哪里去？</p>
<p>因此，基于这三个原因，我又建了个博客。但这里并不想立什么Flag，以往的经验告诉我，立Flag必败。孔子说“朝闻道，夕死可矣”，我想写一篇就收获一篇，不问结果，只管耕耘。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何打造保险行业数字化业务]]></title>
    <link href="https://xuesong.tech/16981080558127.html"/>
    <updated>2023-10-24T08:40:55+08:00</updated>
    <id>https://xuesong.tech/16981080558127.html</id>
    <content type="html"><![CDATA[
<p>2020年突如其来的新冠疫情加速了全球的数字化时代步伐。我们看到各行各业，包括政府部门都在加速数字化转型。保险行业面临数字化转型的新机遇，如何打造数字化业务，已经是一个不容回避的课题。</p>
<p>本文首先探讨数字化时代保险行业的变革，分析传统保险公司面临的挑战，并提出打造数字化业务的方法，最后以一家虚拟的X保险公司作为示例，展示如何帮助它打造自己的数字化业务，从而实现其战略目标。</p>
<span id="more"></span><!-- more -->
<h2><a id="1%E6%95%B0%E5%AD%97%E5%8C%96%E8%BD%AC%E5%9E%8B%E9%A9%B1%E5%8A%A8%E4%BF%9D%E9%99%A9%E8%A1%8C%E4%B8%9A%E5%8F%98%E9%9D%A9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 数字化转型驱动保险行业变革</h2>
<p>最近10年，IT技术的快速发展，特别是互联网、大数据、云计算、物联网、可穿戴设备、人工智能和区块链等技术的进步和综合应用，已经给我们的生活带来了翻天覆地的变化。在保险行业，数字化已经或将在各个方面产生巨大变革，我们认为其中有三个方向值得关注。</p>
<p><img src="media/16981080558127/16981080684342.png" alt="jTaCoFdScxjGy3a4Lm0pLh3UGLfHyFkZCpvE8MFf6qmb3kIec7hiN1qk9QDUJ8CkXJ4Lao1HdX81f_lo_kXLW4aCSmbRWJRPd6B5OW-huCeV0S0q8oinqxHmo8HsghJq7MA-Hmlt.png" /></p>
<h3><a id="1-1%E6%95%B0%E5%AD%97%E5%8C%96%E5%B0%86%E9%87%8D%E5%A1%91%E4%BF%9D%E9%99%A9%E4%BB%B7%E5%80%BC%E9%93%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.1 数字化将重塑保险价值链</h3>
<p>保险核心价值链可以分为保险产品设计、营销与分销、核保与承保、理赔与服务、资产管理等五个环节。我们看到每一个环节都正在发生数字化变革，这些变革帮助保险公司提升经营效率，为消费者提供更优质的产品和服务。</p>
<p>最明显的变化来自销售端，渠道的变化最快。传统的渠道严重依赖于代理人和中介。据公开资料显示，13个月的代理人留存率逐年下降，甚至不足30%。部分险种65%以上的保费作为手续费被中介机构拿走。过去几年，互联网保险已经不是新鲜事物。未来的销售渠道将向保险公司自己的数字化销售体系和具备客户触达能力的平台型公司集中。</p>
<p>在产品设计方面，目前主流的保险产品都以损失后赔偿，对冲风险为主。随着人工智能与传感器的应用，未来将有更多的产品将转向阻止损害发生。这是对保险产品的颠覆式变化。例如美国恒康 人寿保险公司宣布已经停止承保传统寿险，转而销售基于可穿戴设备跟踪健身和健康数据的交互式新型保险。通过运动健康数据方面来吸引客户，根据获得的数据来调整投保人保费或给予折扣。</p>
<p>在理赔端，运用机器学习、医疗知识图谱等技术，自动理赔、快赔、闪赔开始出现并将快速普及。前几年我们看到11.11的时候，各大电商比拼谁的物流快。0点下单，凌晨就送货了。同样的场景也出现在保险行业，在重大事故发生时，保险公司也在比拼理赔的速度。</p>
<h3><a id="1-2%E5%9C%BA%E6%99%AF%E5%92%8C%E6%95%B0%E6%8D%AE%E5%8A%A0%E9%80%9F%E4%BF%9D%E9%99%A9%E4%BA%A7%E5%93%81%E5%88%9B%E6%96%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.2 场景和数据加速保险产品创新</h3>
<p>保险产品的设计将越来越依赖基于数据定义的场景和客户需求，并通过特定渠道精准触达，然后通过运营反馈快速进行产品迭代。</p>
<p>保险产品与普通商品相比，有一些特殊性：</p>
<ul>
<li>保险产品可以被快速复制，不存在知识产权壁垒问题。一个新产品研发出来，别的保险公司可以快速复制条款或稍作改动就推出相同的产品。以百万医疗险为例，2016年8月众安在线推出第一款“百万医疗险”尊享e生，第二年“百万医疗险”就如雨后春笋般面市。</li>
<li>随着大众对保险认知走向成熟和理性，品牌不再是主要考虑因素。因为即使保险公司破产也不会对投保人产生影响，银保监会将接管兜底，购买的保险并不会因此失效。</li>
</ul>
<p>保险产品的这些特点，意味着保险公司需要持续产品创新，并且努力在价格、运营、渠道等方面保持竞争力。</p>
<p>我们看到面向特定场景，基于大数据分析的创新型产品正在持续推出。例如大家已经熟知的退货运费险、手机碎屏险等。还有爱选科技通过整合80家保险公司的3000多种保险产品，以C端客户需求设计产品，多样化解决方案，实现标准化、精细化和专业化的管理。</p>
<p>产品的定价模式也在发生变化。目前的产品定价以保险大数法则为原则，当样本足够大时，保险公司就可以比较精确的预测风险，合理的厘定保险费率。而基于大数据分析的个性化定价模式也正在悄然兴起。例如英国大数据公司Cytora正在帮助保险公司精细化保险定价，未来可能出现千人千险的局面。</p>
<h3><a id="1-3%E6%95%B0%E5%AD%97%E7%94%9F%E6%80%81%E5%88%9B%E9%80%A0%E4%BF%9D%E9%99%A9%E7%A7%91%E6%8A%80%E7%9A%84%E6%9C%AA%E6%9D%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.3 数字生态创造保险科技的未来</h3>
<p>除了前面介绍的保险产品特殊性外，保险产品购买的频次也非常低，无法建立客户黏性。寿险产品每年续保一次，甚至多年才需要补充购买，而公众对家庭财产保险的保险意识还非常弱。</p>
<p>未来的出路在于构建数字生态。以保险为工具，连接各类优质服务提供商，增加客户触点、提升客户黏性，打造保险+服务的新商业模式。例如部分保险公司推出的药品直送、在线健康问诊、就医绿色通道等等。</p>
<p>数字生态的建设主要包括：</p>
<ul>
<li>构建数字化渠道：实现保险公司全渠道、全业务、全场景的服务体验。</li>
<li>打造生态圈提升获客能力：发挥保险公司自身优势，与相关产业和服务提供商互动合作，实现共赢。例如平安集团打造的出行、医疗健康、房产等主要生态场景，以及平安健康保险引入Discovery Vitality 的 “健行天下”。</li>
<li>开放保险能力：开放银行概念的兴起对保险行业具有很好的示范作用，保险能力开放将大幅提升保险公司的市场竞争力。例如德国的安联集团对内部开放其保险核心系统，使合作商可以在资源共享的平台上共同开发系统；对外部接入其他平台和应用，投保人可以从第三方平台购买其产品。</li>
</ul>
<h2><a id="2%E4%BC%A0%E7%BB%9F%E4%BF%9D%E9%99%A9%E5%85%AC%E5%8F%B8%E5%9C%A8%E6%95%B0%E5%AD%97%E5%8C%96%E6%97%B6%E4%BB%A3%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 传统保险公司在数字化时代面临的挑战</h2>
<p>面对数字化时代保险行业的变革，传统保险公司用有丰富的产品资源和庞大的线下渠道优势，但面临的挑战也非常明显。</p>
<p><img src="media/16981080558127/16981080684361.png" alt="6EFDE9C1-AFAB-4958-9FDA-3059242E01BD.png" /></p>
<h3><a id="2-1%E6%95%B0%E5%AD%97%E5%AF%A1%E5%A4%B4%E5%85%A5%E4%BE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.1 数字寡头入侵</h3>
<p>据中金公司的研究报告，未来10年，互联网保险市场规模将达到2.5万亿，是2019年全年保险市场的58%，相当于再造了半个保险市场。而保险潜在客户群体的年轻化、高教育程度和在线消费习惯，都会造成互联网保险对传统保险模式的替代是不可阻挡的。</p>
<p>传统保险公司正在面临数字寡头等新参与者的竞争。例如蚂蚁金服旗下的“相互宝”产品，上线第一周会员就突破1000万，截止2020年，会员已经达到1亿，而平安最新年报显示其到2020年12月末，个人客户数2.18亿。尽管相互宝是一款争议很大的产品，但从中可以看到数字寡头们的客户触达的精准性、更高效的运营能力和强大的基础设施，而这些都是传统保险公司所欠缺的能力。</p>
<h3><a id="2-2%E5%8E%86%E5%8F%B2%E5%8C%85%E8%A2%B1%E6%B2%89%E9%87%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.2 历史包袱沉重</h3>
<p>公众印象中可能觉得传统保险公司都有一流的人才和现代化的信息系统。然而事实是除了头部的保险公司很早就开始数字化转型外，大部分传统保险公司都面临巨大的数字化转型压力。</p>
<p>如果从上世纪末算起，经过20多年的信息化建设，保险公司的各项运营和管理都已经实现了信息化。然而烟囱林立、数据孤岛问题较为突出，难以形成客户洞见，突出规模和协同效应。</p>
<p>另外，传统保险公司难以跟上IT技术飞速发展的步伐。以保险核心系统为例，这几乎是所有保险公司的痛。一方面它确实长期以来支撑了公司的保险业务，立下汗马功劳。另一方面，这些系统大都始建于上世纪末或本世纪初，技术相当落后。例如有的采用存储过程实现业务逻辑，有的使用COBOL语言开发。落后的技术和长期技术债务的积累，都导致核心系统难以支撑业务的快速变化。</p>
<h3><a id="2-3%E5%B8%82%E5%9C%BA%E5%8C%96%E6%9C%BA%E5%88%B6%E4%B8%8D%E8%B6%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.3 市场化机制不足</h3>
<p>传统大型保险公司在产品的市场化创新、跨部门间协作和人员激励等方面存在不足，难以形成以客户为中心、以市场为导向，快速响应、高效运营的机制。</p>
<p>不论是保险价值链的重塑，还是产品创新和生态打造，通常都会跨业务条线、跨业务部门 ，这就需要市场、IT、运营、合作伙伴等相关各方有机协同与合作。为了应对这种挑战，我们看到当前大型保险公司都在设立数字化创新组织，建立创新流程和机制。但需要提醒的是，单独设立创新组织并不意味着原有的组织结构和协作方式就不需要调整。因为即使小到一个产品的交付也需要跨团队的协作，DevOps的兴起已经很好地说明了这一点。</p>
<p>数字化时代所有行业都面临人才匮乏的问题。 大多数保险公司不得不长期依赖IT外包，存在外包比重过大、自有IT骨干人员少，没有建立起人才梯队的问题。借用DDD的领域划分，就是没有在核心域上建立起自己的竞争力。而数字化是一场变革，产业创新的压力穿过前端，直达中台、后台，人才选用、培养、激励机制的配套已经刻不容缓。</p>
<h2><a id="3%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E5%8C%96%E4%B8%9A%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. 如何打造现代数字化业务</h2>
<p>纵观数字化时代保险行业的变革和挑战，我们发现这并不是保险行业所特有的情况，而是时代发展带来的必然结果。我们已经看到数字化时代的先驱者们（Google、Amazon、Netflix、阿里和腾讯等等）如何树立标杆，成为其他企业追逐的对象。诚然，并不是每一家企业都要成为先驱者、颠覆者，但每一家企业都要在数字化时代找到自己的定位、制定有针对性的战略，并实现自己的战略目标。</p>
<p>ThoughtWorks公司是一家IT领域的专业服务公司。通过对数字化时代先驱者们的深入研究，并总结自身超过25年与不同组织合作、帮助他们发展数字能力的经验，ThoughtWorks提出了打造现代数字化业务(Mordern Digital Business, MDB)的方法。</p>
<p>限于篇幅的原因，本文简要介绍其方法，详细内容请阅读文后的参考书籍和<a href="https://www.thoughtworks.com/perspectives/edition8-modern-digital-business">ThoughtWorks官方网站</a>。</p>
<p>ThoughtWorks认为现代数字化业务的关键能力是<strong>深入客户的洞察、缩短上市时间和创新数字化收益</strong>。ThoughtWorks创新总监肖然在 <a href="https://insights.thoughtworks.cn/techocore-digital-platform/">数字化时代的科技双模，双模IT成为过去式 - ThoughtWorks洞见</a> 文章最后对这三个关键能力进行了详细解读。</p>
<p>要具备这样的关键能力，企业首先需要改变思维方式，建立数字化思维，它具有7个关键特征：</p>
<ol>
<li><strong>客户共情</strong>：站在客户的立场，去解决客户的问题，而不是卖给客户什么产品。</li>
<li><strong>成效导向</strong>：资源的投入应该考虑衡量价值，对齐真正的成效，而不是工作量。参考<a href="https://insights.thoughtworks.cn/outcome-over-output/">关注成效而非产出 - ThoughtWorks洞见</a></li>
<li><strong>快速响应</strong>：按照精益原则，建立更小的工作批次反馈闭环，而不是憋大招。参考<a href="https://insights.thoughtworks.cn/practice-in-promoting-business-agility/">提升业务响应力：践与行 - ThoughtWorks洞见</a></li>
<li><strong>创新型文化</strong>：在组织中建立实验型思维，鼓励试错，而不是惩罚错误。参考<a href="https://insights.thoughtworks.cn/innovation-culture/">是什么在扼杀你的创新文化？ - ThoughtWorks洞见</a></li>
<li><strong>数据驱动战略</strong>：以数据洞察驱动决策，而不是领导拍脑袋。参考<a href="https://insights.thoughtworks.cn/edge-data-driven-decision/">量化IT投资成效，以数据驱动决策 - ThoughtWorks洞见</a></li>
<li><strong>低摩擦组织治理</strong>：打破部门墙，提升组织响应速度。参考<a href="https://insights.thoughtworks.cn/from-agile-transformation-to-lean-enterprise/">从敏捷转型到精益企业 - ThoughtWorks洞见</a></li>
<li><strong>科技重构业务</strong>：技术不仅仅强化业务，更不是成本中心，而应该是业务战略的核心，持续重构业务。</li>
</ol>
<p>思维的改变并不容易，企业需要通过改变行为，并投资于现代数字化业务的5个核心支柱来实现：</p>
<p><img src="media/16981080558127/16981080684379.png" alt="939CF2AC-9CF8-4AD6-8B43-567F9FAE5533.png" /></p>
<ol>
<li><strong>低摩擦的运营模式</strong>：提高企业应对变革的能力</li>
<li><strong>企业级平台战略</strong>：创建与业务战略相适应的技术平台</li>
<li><strong>客户洞察和数字化产品能力</strong>：快速设计和交付卓越的产品和用户体验且不断进行演进</li>
<li><strong>智能驱动的决策机制</strong>：利用数据资产开启新的价值来源</li>
<li><strong>工匠精神和科技思维</strong>：在软件开发中利用模式与最佳实践，追求卓越</li>
</ol>
<p>当企业决定投资于这5个核心支柱时，需要回答一个问题，每个支柱的能力应该投资多少，目标是什么？业界常常通过成熟度模型来评估，例如DevOps成熟度模型。成熟度越高，证明能力越强。然而每个企业的上下文不一样，战略目标不一样。一个卖衣服的电商并不需要淘宝那样的企业级平台战略，所以成熟度并不能解决这个问题。</p>
<p>ThoughtWorks开创性地引入了<a href="https://www.thoughtworks.com/cn/digital-fluency">数字化流畅度</a>来平衡投资、降低风险。以买衣服的电商来说，在企业级平台战略方面，其流畅度可能只需要达到”执行“就可以了，不需要做过多的投资。而淘宝在这个支柱则需要大量投资，使其达到“强化“级别的流畅度。关于流畅度与成熟度的区别可以参考<a href="https://insights.thoughtworks.cn/apability-maturity-model/">成熟度模型罪与罚 - ThoughtWorks洞见</a></p>
<p><img src="media/16981080558127/16981080684408.png" alt="dfm.png" /></p>
<p>改编自AgileFluency®Project  <a href="https://www.agilefluency.org/">agilefluency.org</a></p>
<p>应用数字化流畅度去定义每一个支柱的目标流畅度，就可以找到每一个支柱的目标是什么，需要的举措有哪些。然后制定计划执行这些举措，实现数字化业务的打造，从而实现企业战略目标。</p>
<h2><a id="4%E6%89%93%E9%80%A0-x%E4%BF%9D%E9%99%A9%E5%85%AC%E5%8F%B8%E7%9A%84%E6%95%B0%E5%AD%97%E5%8C%96%E4%B8%9A%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. 打造X保险公司的数字化业务</h2>
<p>下面我们以X保险公司为例，简要介绍如何为其打造数字化业务。请注意，因为每个企业上下文不同，所以其流程度的要求和对应要投资的内容是不同的。</p>
<p>X保险公司是一家传统的大型保险公司，面对数字化时代的挑战，迫切需要打造具有竞争力的数字化业务。该公司希望：</p>
<ol>
<li>全面优化运营体系，提升端到端的运营效率、降低运营成本</li>
<li>建立个人保险产品创新机制</li>
<li>建立数字化生态、开放保险能力，链接生活、健康、出行、养老等服务提供商，提供无缝的客户体验</li>
</ol>
<p>通过战略目标拆解、访谈和工作坊，我们为其设计了流畅度要求。如下图：</p>
<p><img src="media/16981080558127/16981080684442.png" alt="65698C26-4078-4AFA-BCF5-EC1235773E53.png" /></p>
<h3><a id="4-1%E4%BD%8E%E6%91%A9%E6%93%A6%E7%9A%84%E8%BF%90%E8%90%A5%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.1 低摩擦的运营模式</h3>
<p>在“低摩擦的运营模式”支柱，X保险公司需要达到“执行”级别的流畅度。意味着组织建立了跨部门的协作机制，打通端到端的运营价值流，并持续优化。组建跨职能的全功能团队。业务和技术共同创建计划，具有一致且明确的优先级。技术战略用来支持业务战略，项目和计划采用增量的方式运作。</p>
<p>为了达到“执行”的流畅度要求，X保险公司应该投资于：</p>
<ul>
<li>敏捷与精益原则</li>
<li>IT，运营和业务协作</li>
<li>业务和IT共享待办事项</li>
<li>共享成效度量</li>
<li>持久的跨功能团队</li>
<li>在制品限制</li>
</ul>
<h3><a id="4-2%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%B9%B3%E5%8F%B0%E6%88%98%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.2 企业级平台战略</h3>
<p>在“企业级平台战略”支柱，X保险公司需要达到“强化”级别的流畅度。意味着要在整个组织的IT架构能够满足当今需求，并且能够适应未来的变化。例如快速建立与第三方服务的集成并提升整体价值。组织也了解康威定律，能够积极地重组团队以创建流畅的现代体系结构。API生态系统得到了广泛应用，可以为客户创造新价值。该组织可以很好地创建平台业务，业务本身就是平台。</p>
<p>为了达到“强化”的流畅度要求，X保险公司应该投资于：</p>
<ul>
<li>改造遗留资产</li>
<li>DevOps文化</li>
<li>自助化基础设施平台</li>
<li>业务API生态系统</li>
<li>云原生的架构</li>
<li>演进的架构</li>
<li>平台SLA</li>
</ul>
<h3><a id="4-3%E5%AE%A2%E6%88%B7%E6%B4%9E%E5%AF%9F%E5%92%8C%E6%95%B0%E5%AD%97%E5%8C%96%E4%BA%A7%E5%93%81%E8%83%BD%E5%8A%9B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.3 客户洞察和数字化产品能力</h3>
<p>在“客户洞察和数字化产品能力”支柱，X保险公司需要达到“执行”流畅度。意味着业务成效是明确定义的，能够反映客户价值，并且在整个组织得到广泛理解。客户体验是首要关心的，设计思维、从实验中学习等技术被用于解决问题。产品决策由业务视角驱动。</p>
<p>为了达到“执行”的流畅度要求，X保险公司应该投资于：</p>
<ul>
<li>设计思维</li>
<li>稳定的跨功能团队</li>
<li>用户研究</li>
<li>精益切片执行</li>
<li>建立设计系统</li>
<li>测试、学习的技术</li>
<li>用户体验愿景和战略</li>
</ul>
<h3><a id="4-4%E6%99%BA%E8%83%BD%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%86%B3%E7%AD%96%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.4 智能驱动的决策机制</h3>
<p>在“智能驱动的决策机制”支柱，X保险公司需要达到“专注”流畅度。意味着数据在很大程度上被视为信息，组织从原始数据中寻求知识和机会。数据仍然相对孤立。洞察力主要通过基本的报告技术收集。</p>
<p>为了达到“专注”的流畅度要求，X保险公司应该投资于：</p>
<ul>
<li>数据工程</li>
<li>数据安全与隐私</li>
<li>描述性数据分析</li>
<li>报告及驾驶舱</li>
</ul>
<h3><a id="4-5%E5%B7%A5%E5%8C%A0%E7%B2%BE%E7%A5%9E%E5%92%8C%E7%A7%91%E6%8A%80%E6%80%9D%E7%BB%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.5 工匠精神和科技思维</h3>
<p>在“工匠精神和科技思维”支柱，X保险公司需要达到“优化”流畅度。意味着技术团队与业务能够紧密合作，实现了快速创新和业务敏捷性。他们可以在整个组织中清晰地了解技术选择，从而做出积极的技术选择。团队对他们的自动化测试套件充满信心，从一开始就保证质量。开发人员的经验是宝贵资产，技术骨干占有合适的比例。“技术专家”是受人尊敬的职业道路。</p>
<p>为了达到“优化”的流畅度要求，X保险公司应该投资于：</p>
<ul>
<li>完全自动化的基础设施</li>
<li>Observability as code</li>
<li>软件可靠性工程（SRE）</li>
<li>全自动化测试</li>
<li>开发团队自服务</li>
<li>开发者体验</li>
<li>基于风险的工程方法</li>
</ul>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>数字化时代保险行业的变革已经来临，保险公司需要明确战略目标，找到数字化时代自己的定位。借助ThoughtWorks的<a href="https://www.thoughtworks.com/cn/digital-fluency">数字化流畅度</a>模型，根据自己的上下文，找到5个核心支柱的目标流畅度，并制定相应的举措和投资计划，最终打造出具有竞争力的数字化业务。</p>
<p>更多信息请参考：</p>
<p><img src="media/16981080558127/16981080684490.jpg" alt="s33754324.jpeg" /></p>
<p><img src="media/16981080558127/16981080684502.jpg" alt="s33849814.jpeg" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用DDD和演进式架构对遗留系统进行改造]]></title>
    <link href="https://xuesong.tech/16981079624519.html"/>
    <updated>2023-10-24T08:39:22+08:00</updated>
    <id>https://xuesong.tech/16981079624519.html</id>
    <content type="html"><![CDATA[
<p>这几天大连车务段火了，因为Flash停用，导致车系统不能用，奋战24小时用Ghost和Flash降版本恢复使用。本来恢复就恢复了，可是把这个宣传成敢于攻关、敢于创新、敢于领先，就被全网程序员笑话了。</p>
<p>可是程序员朋友们，先别笑话那些业余选手，想想你手上的遗留系统改造了吗？</p>
<span id="more"></span><!-- more -->
<p>美国有位学者做了个研究：<a href="https://spectrum.ieee.org/computing/it/inside-hidden-world-legacy-it-systems">IT遗留系统的隐藏世界</a>，他发现从2010年以来的10年内，全球的政府和企业花费了大约35万亿美元在IT系统和服务上，其中3/4用于维护现有的系统。至少有2.5万亿美元用来替换这些遗留系统，然后其中7200亿美元浪费了，因为替换失败。</p>
<p><img src="media/16981079624519/16981079769095.jpg" alt="Xnip2021-01-17_12-34-44.jpeg" /></p>
<p>图片来源：<a href="https://spectrum.ieee.org/computing/it/inside-hidden-world-legacy-it-systems">Inside the Hidden World of Legacy IT Systems</a></p>
<p>这是一个巨大的市场，而且咱们中国的遗留系统也会越来越多。但是困难也是很明显的，这些遗留系统一般承担着企业的核心业务，这些业务年久失修，当年的业务分析师找不着了、没文档、没测试，甚至有的供应商都没了。</p>
<p>对待这些遗留系统，怎么办呢？其实很矛盾，继续维护老系统吧，部门不出成绩，业务还老抱怨。重新开发新系统吧，这个锅大得很，不好接。毕竟这么多年的业务，能不能搞得定不说，辛苦开发完了，也要很久才能稳定下来，同样少不了抱怨。</p>
<p>最近几年，我做了好几个大型遗留系统的改造咨询项目，每个都是几百万行代码，有的系统已经有20年，最少的也有10几年。在看了几十万行代码、吸取了  <a href="https://www.martinfowler.com/">Martin Fowler</a> 、Eric Evans和<a href="http://nealford.com/">Neal Ford</a>等大牛的思想精华和自己的实践后，我逐渐认清了遗留系统这样一个现实：</p>
<ul>
<li>重构无门</li>
<li>重写看缘分</li>
<li>绞杀才是王道</li>
</ul>
<h2><a id="1%E9%87%8D%E6%9E%84%E6%97%A0%E9%97%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 重构无门</h2>
<p>为什么重构无门？Martin Fowler定义的重构：</p>
<blockquote>
<p>重构是在不改变代码行为的前提下，对其进行一系列小的改造，旨在改进系统结构的实践活动。</p>
</blockquote>
<p>重构不改变业务逻辑、不加需求。程序员通过一系列重构手法，消除一个个坏味道，从而让代码更加合理、整洁。</p>
<p>之所以说重构无门，是因为我看到这样两个现象：</p>
<ul>
<li>系统没有重构价值：本来不复杂的业务逻辑，由于混杂了业务和技术的复杂性，代码又腐化得严重，导致系统过于复杂，而且普遍没有测试。在这种情况下重构的成本太高。</li>
<li>团队没有重构能力：重构是一项需要具备很高技能的活动，遗憾的是绝大多数团队都不具备这样的能力。技术好的程序员一部分走向管理岗位，一部分忙于救火。技术差的程序员继续复制粘贴，挖更多的坑。重构是一项还需要大多数程序员长时间修炼的技能。</li>
</ul>
<p>如果你恰好遇到以上两个情况，你可以放弃重构这条路了。</p>
<h2><a id="2%E9%87%8D%E5%86%99%E7%9C%8B%E7%BC%98%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 重写看缘分</h2>
<p>程序员是最喜欢重写的。脱离了老代码的技术债，可以在一片绿地上尽情地撒野。</p>
<p>对于遗留系统，如果没有高层的支持、业务部门的全力配合，给力的开发团队，重写基本就是个不可能完成的任务。</p>
<p>重写要特别注意系统切换的风险，如果等到最后全部完成再上线切换，不说是死路一条吧，至少也要损失半条命。</p>
<p>重写还要考虑周期不能太长，否则攒的一堆业务需求，业务方的压力可能会无法承受。</p>
<p>在我看来，**重写最致命的问题可能是一帮程序员在辛苦了半年、一年后，又重新开发了一个遗留系统。**因为在不断赶工、临时组建团队、业务不熟的情况下，只能牺牲质量来完成任务。</p>
<p>当然，在国内的环境，我还没有看到重写失败的案例，因为压根就不存在会失败的项目。所以我说重写是看缘分。</p>
<h2><a id="3%E7%BB%9E%E6%9D%80%E6%89%8D%E6%98%AF%E7%8E%8B%E9%81%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. 绞杀才是王道</h2>
<p><a href="https://www.martinfowler.com/bliki/StranglerFigApplication.html">绞杀</a>是Martin Fowler总结出来的一种模式，它来源于绞杀植物的一种隐喻。</p>
<blockquote>
<p>绞杀植物，又名杀手树，指一种植物以附生来开始它的生长，然后通过根茎的成长成为独立生活的植物，并采用挤压、攀抱、缠绕等方式盘剥寄树营养，剥夺寄树的生存空间，从而杀死寄树。</p>
</blockquote>
<p>这种植物包围着其它树的树干生长，并且向下扩展延伸，直到根系，然后快速生长，阻断里面的“寄树”的养分传输，最后导致其死亡。</p>
<p><img src="media/16981079624519/16981079769111.jpg" alt="david-clode-T49WTav4LgU-unsplash (1).jpeg" /></p>
<p>Photo by  <a href="https://unsplash.com/@davidclode?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">David Clode</a>  on  <a href="https://unsplash.com/s/photos/strangler-figs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></p>
<p>绞杀模式，就是不断增量地构建新系统来替换掉遗留系统，杀死老的，重建新的。</p>
<p>为什么说绞杀才是王道呢，至少有这么几个原因：</p>
<ul>
<li>风险小：不像重写那样大动干戈，每次只替换一点，风险较小。</li>
<li>不影响业务：可以同时绞杀和新需求的开发，不需要暂停业务。</li>
<li>可操作：做局部的业务功能重写，从技能上对团队的要求没有那么高。但是要注意好边界的划分。</li>
</ul>
<h2><a id="4%E5%A6%82%E4%BD%95%E7%BB%9E%E6%9D%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. 如何绞杀</h2>
<p>我们来看这样一个典型的遗留系统：系统运行了很多年，数据库结构非常复杂，而且别的系统还通过数据库集成，代码很混乱、模块之间耦合得非常严重，直接访问甚至修改其它模块的数据库表是很常见的事情。当然，作为一个遗留系统，测试肯定也是几乎没有的。</p>
<p><img src="media/16981079624519/16981079769131.jpg" alt="Xnip2021-01-18_06-49-44.jpeg" /></p>
<p>对于这样一个遗留系统，如何进行绞杀呢？</p>
<h2><a id="4-1%E6%94%B6%E7%BA%B3%E6%B3%95%EF%BC%9A%E4%B8%8D%E6%94%B9%E5%8F%98%E7%BB%93%E6%9E%84%EF%BC%8C%E5%88%86%E9%97%A8%E5%88%AB%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.1 收纳法：不改变结构，分门别类</h2>
<p>想象一下，如果你家里常年不收拾，东西非常凌乱，冬天、夏天的衣服，包括外衣、内衣、袜子等等都散落各个地方，各种玩具、杂物也散落得随地都是，你会怎么整理呢？</p>
<p>有一种新的职业叫收纳师，提供上门整理收纳的服务。收纳师会帮你收拾整理，分门别类地把东西放在适当的地方，但是不会调整内部的结构，例如不会动柜子、沙发、插座的位置。</p>
<p>对于遗留系统，同样可以运用收纳法进行第一步改造。因为老系统通过数据库集成，所以不能改变它的结构，但是要逐渐把代码分门别类地规整到不同的对象上。</p>
<p>这时候可以采用DDD的战术建模方法，对老的DB进行建模，提取出领域模型，这个新的领域模型就是一个收纳包。然后逐个梳理业务场景，将业务逻辑整理到新的收纳包中。</p>
<p><img src="media/16981079624519/16981079769152.jpg" alt="Xnip2021-01-18_07-20-54.jpeg" /></p>
<p>因为收纳包并没有改变数据库结构，Domain Model是业务逻辑的载体，Repository修改老的数据库，所以收纳包对老系统的影响很小，两者可以共存。</p>
<p>在收纳整理的过程中，需要DevOps技术实践和演进式架构的方法：</p>
<ul>
<li>确保每一个收纳动作都是一次增量变更，判断依据很简单：是否可以独立上线。</li>
<li>使用适应度函数，对架构和风险点进行持续评估。例如在改造过程中，两套模型是共存的，如果有业务需求导致其中一套模型发生了变化，需要确保另一套模型也要相应修改，以确保最终的DB不受影响。</li>
<li>“收纳包”应该采用合理的架构模式，例如分层架构。</li>
<li>新的架构要从一开始就做架构守护。</li>
<li>确定测试策略，确保新的业务代码能够做到充足的测试覆盖。</li>
<li>应用DevOps技术，加快构建、测试、部署和运维的反馈环。</li>
</ul>
<p>不断地应用收纳法对一个个业务场景进行整理收纳，你就可以逐步演进到到一个高内聚、低耦合的系统。但这并不是终点，因为这时候领域模型是基于老数据库结构建立的，所以你的聚合可能会比较大、存在很多不合理的地方，接下来可以使用装修大法，实现领域模型的改造。</p>
<h2><a id="4-2%E8%A3%85%E4%BF%AE%E6%B3%95%EF%BC%9A%E9%87%8D%E6%96%B0%E8%AE%BE%E8%AE%A1%EF%BC%8C%E5%88%86%E6%AD%A5%E8%A3%85%E4%BF%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.2 装修法：重新设计，分步装修</h2>
<p>仍然以家庭收纳为例，虽然经过了收纳，东西都在它应该待的地方了。但是可能因为以前的装修不合理，你在这样的空间居住仍然感觉不爽，这时候可能就需要做一些大的动作了。例如重新买柜子、电力线路改造，加几个插座等等。于是，你重新设计了房间，开始装修。</p>
<p>并不是所有家庭都会重新设计装修，因此这一步并不是必须的。当遗留系统经过收纳整理后，就涌现出了很多聚合对象，业务逻辑已经围绕着聚合展开，代码的可维护性已经得到了非常大的提升。</p>
<p>为了进一步优化设计，可以应用装修法，调整聚合的模型，相应也要调整数据库的结构。包括建立新的数据库表、迁移数据、删除老的表。</p>
<p>与收纳法按业务场景改造不同，装修法按聚合进行改造。可以把一个聚合的改造作为一个增量变更，分步骤完成改造。需要注意的是，必须确保涉及到此聚合的所有业务场景都已经完成了第一步收纳的动作，否则仍然无法删除老的数据库表，改造不彻底。</p>
<p><img src="media/16981079624519/16981079769177.jpg" alt="Xnip2021-01-18_10-22-52.jpeg" /></p>
<p>如上图所示，随着领域模型的重新设计优化，一个遗留系统就逐渐重生了。如果老系统的个别表还存在外部系统的集成没有解开，可以通过数据同步完成。</p>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>本文总结了遗留系统改造的方法，认为绞杀是比较理想的选择，风险小，对团队的能力要求没那么高。通过引入DDD战术建模、演进式架构和DevOps实践，可以实现增量、安全地小步绞杀，从而逐步改造出一个新系统。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[原来这样聪明地工作就不用996]]></title>
    <link href="https://xuesong.tech/16980722334047.html"/>
    <updated>2023-10-23T22:43:53+08:00</updated>
    <id>https://xuesong.tech/16980722334047.html</id>
    <content type="html"><![CDATA[
<p>今天看了本好书《卓越工作》，迫不及待地要分享给大家。</p>
<p>作者的第一份工作是在波士顿咨询公司（BCG），加入公司后想着要996大干一番，却发现一女同事早8点晚6点准时下班走，也不加班。关键是工作还做得比自己好。之后的多年时间里，直到他做了哈佛商学院的教授，他都还在思索为什么当年那位女同事能够用更少的时间却能做得更好？</p>
<p>作者发现，没有人愿意愚笨地工作，但大多数人实际上却就在愚笨地工作，因为真的不知道怎么聪明地工作。于是他深度访谈了120位专业人士，调研了5000人后，形成了这本书的内容。</p>
<p>我节选几个观点与大家分享。</p>
<span id="more"></span><!-- more -->
<h2><a id="%E5%B0%91%E5%81%9A%E3%80%81%E5%85%A5%E8%BF%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>少做、入迷</h2>
<p>绩效最好的那些人在工作中会表现出少和多两种特质：<strong>减少分心的活动，增多专注的努力</strong>。</p>
<p>工作表现卓越的人参与的协作项目往往很少。他们小心翼翼地选择将要加入的项目和任务，避开那些想逃掉的工作，然后将自己的努力和资源引导到自己选定并擅长的少量任务上。</p>
<p>对照一下，看看你无法集中注意力是不是因为：</p>
<ul>
<li>较宽的工作活动范围（包括有太多的会议和太多的工作项目）；</li>
<li>诱惑（包括来自他人施加的和自己造成的）；</li>
<li>让人讨厌的、总让你“多做”的老板（他缺乏方向，设置了太多重点工作）。</li>
</ul>
<p>如果是的话，记住：<strong>尽可能做减法；只做必须的加法。</strong></p>
<h2><a id="%E5%81%9A%E6%9C%89%E4%BB%B7%E5%80%BC%E7%9A%84%E4%BA%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>做有价值的事</h2>
<p>别把自己视为一个普通的员工，而要把自己当作一个创新工作者。寻找和治疗痛点，提出“愚蠢”的问题，把注意力聚焦于怎样重新设计和为社会创造极大的价值上。</p>
<p>因为：一个人的工作价值＝为他人产生的价值×质量×效率。</p>
<p>在工作中，所谓的卓越价值，就是创造能极大地有益于他人的产品，这样的产品是高质量和高效率共同生产出来的。</p>
<h2><a id="%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何学习</h2>
<p>你是将一年的经验重复10年，还是每天都追求进步？工作中的什么障碍阻止了你的进步，如何刻意练习（Tasking &amp; 循环学习）？</p>
<p><img src="media/16980722334047/16980722480261.jpg" alt="IMG_CA8E6945EB60-1.jpeg" /></p>
<h2><a id="%E6%89%BE%E5%88%B0%E6%BF%80%E6%83%85%E4%B8%8E%E4%BD%BF%E5%91%BD%E6%84%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>找到激情与使命感</h2>
<p>使命感和激情是不同的。</p>
<ul>
<li>激情是“做你所爱”，”激情问的是：“这个世界能给我带来什么？”</li>
<li>而使命感是“贡献你能贡献的”。使命感问的是：“我能为这个世界做点儿什么？</li>
</ul>
<p>努力找到一个能把自己的价值贡献给公司和社会的任务，然后再把激情投入其使命感中。只有把激情和使命感结合起来，而不是空有激情，才能创造最好的结果。</p>
<p>有三种方法可以增加你的激情和使命感：</p>
<ul>
<li>发现你的新角色。你可以在你目前所待的地方找到正确的匹配点；你不必如猴子掰玉米般跳到另一类激情上去。就在你现在所属的单位找到新角色，让它更好地引导你的激情，增强你的使命感。</li>
<li>扩大你的激情圆。对工作充满激情不仅仅是找到工作本身的乐趣。激情也来自成功、创造性、社会互动、学习和能力等各个方面。利用这些维度扩大你的激情圆。</li>
<li>攀登使命感金字塔。找到更多能够增加价值的方法</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[新的一年从《心灵奇旅》说起]]></title>
    <link href="https://xuesong.tech/16981080069017.html"/>
    <updated>2023-10-24T08:40:06+08:00</updated>
    <id>https://xuesong.tech/16981080069017.html</id>
    <content type="html"><![CDATA[
<p>今天看了最近大火的动画片《心灵奇旅》，可能因为评分高，所以我的期望值过高吧，看完后觉得有点小小的失落，但是电影的最后一句话打动了我：</p>
<p><img src="media/16981080069017/16981080164645.jpg" alt="Xnip2021-01-03_17-14-02.jpeg" /></p>
<span id="more"></span><!-- more -->
<p>整部电影在探讨人生的意义，每个人活着都要有目的吗？你可能跟故事的主人翁Joe一样，觉得自己过着无聊的生活，总希望找到自己生活的目标和意义。有时候你得到机会，有时候机会稍纵即逝。当你奋不顾身努力争取机会，而梦想终于实现时，似乎又觉得也不过如此。其实生活就是如此，<strong>高光时刻是生活，秋风落叶也是生活</strong>。</p>
<p>所以不妨珍惜生活，珍惜每一分钟去活着。平凡生活中就有“火花”。每天都有甜有苦，只是每个人都忘了我们就在其中，<strong>不识庐山真面目，只缘身在此山中</strong>。就好像剧中的对白：</p>
<p><img src="media/16981080069017/16981080164661.jpg" alt="soul-water.jpeg" /></p>
<p>怎么样珍惜每一分钟去活着呢？我觉得最好的办法就是写日记！对，写日记！</p>
<h2><a id="%E5%86%99%E6%97%A5%E8%AE%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>写日记有什么好处</h2>
<p>作为一个已经连续写了4年日记的职场人士，我还是有些体会的。</p>
<p>例如，你还记得昨天干了啥吗？是不是还得想一想？前天呢？很多人就会想不起来了。有了日记，你可以快速查看这个月自己又干了啥牛逼和傻逼的事。</p>
<p>日记能帮你<strong>管理好时间</strong>。有一句话我特别欣赏：<strong>如何过一天就是如何过一生</strong>。无论贫富、无论成败，每个人一天都只有24小时。日记能够帮助你规划这一天如何过得更有意义。</p>
<p>日记能帮你<strong>快速进入工作状态</strong>。每天早上先列出今天要做的事情，然后按优先级排序。当你的工作清单列完了，你也已经热身进入工作状态了。</p>
<p>日记能帮你<strong>总结反思</strong>。有了日记，就有了历史数据，可以帮助你定期总结，反思。看看自己的进步、找到成就感。反思自己的不足，制定改进计划。</p>
<h2><a id="%E5%A6%82%E4%BD%95%E5%86%99%E6%97%A5%E8%AE%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何写日记</h2>
<p>写日记的方法因人而异。经过几年的尝试，我逐渐形成了一套自己的写日记方法。</p>
<p>我会在每天早上开始写日记，规划今天要做的事情。每完成一件就划掉一件，这是非常有成就感的时刻。然后在晚上，检查总结一下，补充当天的日记。</p>
<p>我会使用日记模版，我的模版长这样：</p>
<pre><code class="language-other">1. 我今天计划做什么，实际做了什么？

2. 我今天帮助了谁？谁今天帮助了我？

3. 我今天认识了谁？

4. 我今天哪几件事做得比较好？

5. 我今天哪几件事应该改进？

6. 我今天为家庭做了什么？

7. 我今天有什么感悟？
</code></pre>
<p>第1项是当天的计划，我会按优先级列出当天的工作内容，已经完成的用删除线划掉。例如：</p>
<ul>
<li>-写《读书高手》的读书笔记-</li>
<li>-建立公众号-</li>
<li>-写第一篇公众号文章-</li>
<li>陪家人去看电影</li>
</ul>
<p>第2条“我今天帮助了谁？谁今天帮助了我？”的起因是帮助别人使自己快乐，同时对于别人给予自己的帮助也应该感恩。</p>
<p>第2-7条我会在晚上更新。如果某条没有内容，就会直接删除，这样搜索起来就很方便。例如，搜索“我今天认识了谁”，就可以看到所有我认识的人。或者搜索“哪几件事应该改进”，就可以检查下以前的待改进点是不是已经有改进了。</p>
<h2><a id="%E5%A6%82%E4%BD%95%E5%86%99%E6%9C%88%E6%8A%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何写月报</h2>
<p>可能你会奇怪，为什么要写月报呢？其实是强迫自己定期回顾的过程。在每个月的第一天，回顾上个月做的事情，我会使用这个模版：</p>
<pre><code class="language-other">1. 本月工作有哪些重要的事情？

2. 本月家庭有哪些重要的事情？

3. 本月最大的成就有哪些？

4. 本月学到了什么？

5. 本月有哪些应该改进项？
</code></pre>
<h2><a id="%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%A0%E5%BA%94%E8%AF%A5%E5%81%9C%E6%AD%A2%E5%86%99%E6%97%A5%E8%AE%B0%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么时候你应该停止写日记？</h2>
<p>日记能够帮助你记录历史、总结过去、改进自我、每天进步一点点。如果你发现每天记录的就是流水帐，没有任何成就、没有总结出任何改进项，这样的日记多无聊，是不是就应该停止写日记呢？</p>
<p>答案显然是否定的。你不应该停止写日记，而是应该反思为什么你的生活找不到成就感？为什么天天在重复？难道要日复一日、年复一年地这样过下去吗？也许是时候走出舒适区，做出改变了！</p>
<p><strong>新的一年，从写日记开始，希望大家每天进步一点点！</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[架构设计——你的依赖反转了吗？]]></title>
    <link href="https://xuesong.tech/16981081366955.html"/>
    <updated>2023-10-24T08:42:16+08:00</updated>
    <id>https://xuesong.tech/16981081366955.html</id>
    <content type="html"><![CDATA[
<p>最近我给一家传统的大型电子制造业公司做嵌入式系统平台架构咨询。他们的产品硬件部分已经组件化，但是每年都有一部分元器件单元要替换，相应的软件就要修改。最大的痛点就是由于系统耦合严重，一改就容易出问题，工作量还大，团队苦不堪言。</p>
<p>这样的问题不仅出现在嵌入式领域，也出现在传统的软件领域。例如你是否依赖于某个外部系统，想要替换掉它却发现代码已经耦合在一起动不了？又或者某个类库/中间件已经无法满足要求，却又不敢更换？</p>
<p>究竟应该如何处理好外部依赖呢？</p>
<span id="more"></span><!-- more -->
<h2><a id="%E4%B8%BA%E6%88%91%E6%89%80%E7%94%A8or%E4%BE%9D%E9%99%84%E4%BA%8E%E4%BD%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为我所用 or 依附于你</h2>
<p>还以这家公司为例，它有很多的供应商，每年需要更换部分元器件，由此带来的软件挑战非常大。实际上这个时代我们做任何一个产品，都需要涉及很多供应商。那么我们与供应商之间究竟是什么关系，是依附于你还是为我所用？</p>
<p>这个定位非常关键，对我们的设计影响非常大。</p>
<p>什么是为我所用？就是变被动为主动，因为我需要计量单元，所以我用了某家供应商的采样和计量单元，但是，它是为我所用，如果需要，我可以换成另外一家的计量单元，而不是依附于它。</p>
<p>如果是依附于它的时候，系统就会慢慢的与它耦合在一起，导致将来很难被替换，一换就牵一发而动全身，软件就要大改，工作量大，质量还没保障。</p>
<p>因此，对于任何系统集成或者依赖时，都应该在有条件时努力做到：<strong>以我为主、为我所用</strong>。这种行为模式在软件设计领域，就叫依赖反转。</p>
<h2><a id="%E5%A6%82%E4%BD%95%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何依赖反转</h2>
<p>大家可能说，对于强势地位的公司或者标准制定者来说，它当然可以做到不依赖于别人，大家都为它所用。但是对普通公司来说，没有这样的能力怎么办？其实我们可以通过设计手段实现这个目标。</p>
<p>我们看下图的架构。虽然也是分层的架构，但是功能组件依赖于具体硬件，这种时候如果要更换硬件和驱动，上层应用必须修改。</p>
<p><img src="media/16981081366955/16995800789325.jpg" alt="E3688DCE-C0EF-466E-BAED-E123326C1D0A.jpeg" /></p>
<p>依赖反转说的是<strong>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口</strong>。</p>
<p>把依赖反转原则应用到这个场景时，就得到一个更好的设计：增加了第三层硬件抽象层和第四层驱动适配层。第2层的功能组件层并不依赖于下层的硬件和驱动层，而是依赖于第三层硬件抽象层。第5层的硬件及驱动层也应该依赖于第3层硬件抽象层。如果不满足，就通过第4层驱动适配层来适配。</p>
<p><img src="media/16981081366955/16995800789349.jpg" alt="clipboardimage.jpeg" /></p>
<h2><a id="%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>依赖反转有什么好处</h2>
<p>一旦把依赖方向反转，有了硬件抽象层，就可以将不同供应商的差异隔离在抽象层之下，保持上层的干净解耦。这样做有以下好处：</p>
<ul>
<li>当更换下层硬件时不影响上层软件。</li>
<li>快速反馈，极速进化：
<ul>
<li>基于硬件抽象层做测试替身，上层的软件测试可以全部在内存里做了，测试用例的执行可以在毫秒级完成，反馈非常快。因此可以做大量的单元测试。</li>
<li>基于硬件抽象层建立基准测试库。需要更换下层硬件和驱动时，拿这个测试基准库进行测试就可以快速验证了。而且不论什么供应商，都可以使用同一套基准测试库。如果供应商不能够直接满足，就通过适配来实现标准接口。</li>
</ul>
</li>
</ul>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>从嵌入式系统到大型Web应用，我们的系统都无法独立存在，都依赖于外部系统或者要集成外部依赖。是依附于它还是以我为主、为我所用？有什么样的思想就有什么样的设计思路。架构师需要认真思考一下，真的把依赖反转原则用好了吗？你的系统能够快速应对外界的变化吗？</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DDD之聚合持久化应该怎么做？]]></title>
    <link href="https://xuesong.tech/16981079214895.html"/>
    <updated>2023-10-24T08:38:41+08:00</updated>
    <id>https://xuesong.tech/16981079214895.html</id>
    <content type="html"><![CDATA[
<p>说到DDD难，我觉得主要是两点：建模难、代码落地难。前者需要业务熟、功力深，难以快速提升；后者难在缺乏简单易行的可参考的代码结构，一旦有了这样的参考结构，就可以快速大幅降低DDD的实践难度。本文从后者的诸多难点中选择一个最常见的问题进行探讨：如何优雅地实现聚合的持久化？</p>
<span id="more"></span><!-- more -->
<h3><a id="%E6%8C%81%E4%B9%85%E5%8C%96%E4%BB%80%E4%B9%88%EF%BC%8C%E8%B0%81%E6%9D%A5%E5%81%9A%E6%8C%81%E4%B9%85%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>持久化什么，谁来做持久化?</h3>
<p>我们先来看一下，以前我们是怎么做持久化的。下图是一个非常典型的三层架构，业务逻辑层相当于Service层，完成业务处理。持久化主要通过数据访问层完成，这一层会有ORM、DAO等。这时候的实体类是一个JavaBean, 没有行为，它是一个贫血模型。我们会在实体类上加上注解，用来做数据库的持久化。这是非常典型的以数据为中心的编程方式，可能大家开始学编程时就是这么做的，非常成熟，没有什么挑战。</p>
<p><img src="media/16981079214895/16981079379256.jpg" alt="v2-33e08256f987600dcc70e4a7d2e33249_1440w.jpeg" /></p>
<p>但系统复杂度达到一定程度时，以数据为中心的编程方式就会导致业务逻辑散布在各个地方，系统变得很难维护，响应力越来越低。因此Eric提出了领域驱动设计方法。其中一个重要的手段就是分离关注点，将技术复杂度与业务复杂度分离。也就是说，业务代码应该只关注业务逻辑的实现，不需要关心对象如何被持久化到数据库。持久化属于技术实现，与业务无关，它不需要知道业务是如何处理的。因此Eric提出了DDD的分层架构，如下图。其中一个主要的区别在于，我们将业务逻辑从Service中移出来，放在了Domain model中，变成了充血模型，封装在聚合中，应用层Service只是起协调作用。同时，将数据访问层不见了，都放在基础设施层了。</p>
<p><img src="media/16981079214895/16981079379280.jpg" alt="v2-abcc8cf521049a0ede5446257f18cef3_1440w.jpeg" /></p>
<p>那么这时候我们聊持久化的时候，我们持久化的是什么，谁来做持久化？Eric帮我们给出了定义。我们持久化的是聚合。</p>
<p>聚合(Aggregate)就是一组相关对象的集合，我们把它作为<strong>数据修改的单元</strong>。每个聚合都有一个根(Root)和一个边界( Boundary) ——Eric Evans</p>
<p>为什么数据修改的单元是聚合而不是实体或者其它东西呢？因为聚合封装了业务规则，也就是“不变性(Invariants)”，因此我们要把它作为一个整体而不是拆开来，以确保业务规则不被破坏。所以我们要以聚合为单元进行持久化。谁来做这个持久化的工作呢？资源库Repository。以订单为例，这是一个典型的Repository接口定义。</p>
<pre><code class="language-java">public interface OrderRepository {
    public Order findById(String id);
    public void save(Order order);
    public void remove(Order order);
}
</code></pre>
<h3><a id="%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96%E6%A8%A1%E5%9E%8B%E8%A6%81%E5%88%86%E7%A6%BB%E5%90%97%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>领域模型和持久化模型要分离吗？</h3>
<p>当我们做持久化的时候，问题来了，我们需要单独的持久化模型吗？或者说，领域模型和持久化模型要分离吗？当你做持久化时，是直接拿领域模型做持久化，还是转换成持久化模型后做数据库保存。我遇到很多团队在这个问题上有分歧。有的说我这个系统的领域模型和持久化模型基本是一样的，没必要分离。另一部分观点说，这两种模型的职责是不一样的，应该分离，这样它们才能够分别独立演进。这两种听起来都很有道理。怎么选择？</p>
<p>我认为，应该分离这两种模型。原因非常简单，如果不分离，你的领域模型必然要为了持久化而妥协。比如说，你在设计领域模型时，要考虑如何保存到数据库中。更为糟糕的是，你还要满足ORM框架的要求，你要有空的构造方法，还要加上各种Setter。当你妥协完了后，你如何确保值对象是只读的？当你的属性很容易就被Set方法改变时，你如何封装你的业务规则？所以，通常我们都需要把领域模型和持久化模型分离。</p>
<h3><a id="nosql%E6%98%AF%E6%9C%80%E9%80%82%E5%90%88%E7%9A%84%E8%81%9A%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E5%90%97%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NoSQL是最适合的聚合持久化方案吗？</h3>
<p>但是，有没有例外呢？有，因此我们有了第2个问题：NoSQL是最适合的聚合持久化方案吗？我们知道NoSQL数据库以文档的方式保存数据，而聚合就可以作为一个文档，它天然就满足了聚合作为一个数据修改的单元，并且在一个事务中完成持久化的需求。我们根本不需要持久化对象，聚合本身就可以做持久化，看起来非常完美。</p>
<p>但是，通常NoSQL不支持ACID，不支持多文档的事务。例如当你有一个聚合要保存，并且同时还要保存领域事件时，他们作为不同的文档分别保存，你如何将它们放到同一个事物中当中？你可能说MongoDB已经支持ACID了，可以让这两个文档在同一个事物中，但是它毕竟才推出不久，而且性能怎么办？所以你在选型时，肯定会谨慎一些。另外，技术选型是个综合权衡的过程，要考虑多方面的因素。你肯定不会仅仅因为它更容易做聚合的持久化而选择NoSQL。所以我们还是要寻找一个更通用的解决方案。</p>
<h3><a id="%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%AC%E8%B4%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>问题的本质</h3>
<p>让我们回到问题的本源。以订单支付这个场景为例，如下图所示。订单有订单头，有订单行，都保存在数据库中，它们构成了订单聚合。当我要做订单支付业务时，首先我们通过Repository，从数据库中得到聚合，传给Service。Service调用order.pay()方法完成业务逻辑的处理，这时候订单的状态发生了变化。然后再由Repository将变化后的聚合保存到数据库中。</p>
<p><img src="media/16981079214895/16981079379301.jpg" alt="v2-f150b7d5ebf4c29e361b4656f3be5323_1440w.jpeg" /></p>
<p>但是这时候我们只有聚合的最新状态，不知道聚合发生了什么变化。因为我们前面提到分离领域模型和持久化模型。所以这时候没有Hibernate之类的框架帮我们维护状态。聚合之前的状态在哪里？在数据库里。如果从数据库再查询一遍，不仅有性能损耗，而且代码也不好看。所以现在的问题变成了，我们怎么得到聚合的原始状态，这样我们才能够去做对比，从而更高效地修改数据。我们可以参照Hibernate搞个一级缓存吗。这又会引入另一个复杂度。我们不想为了解决一个问题引入另一个问题。有没有轻量级的解决办法呢？</p>
<p>我们设想一下，如果我们从Repository返回的不是聚合，而是一个聚合的容器。在这个容器中，不仅有聚合，还有聚合的历史快照，是不是就解决这个问题了。当你把聚合放到容器中时，它会自动创建一个快照。因此保存的时候，我们就能够通过对比快照知道聚合发生了什么变化。</p>
<p><img src="media/16981079214895/16981079379316.jpg" alt="v2-a6dfe601a7da7004b57dfd20709d30de_1440w.jpeg" /></p>
<p>我们来看下相应的代码。Repository接口稍稍做一点调整，它的返回类型和参数变成了Aggregate泛型。</p>
<pre><code class="language-java">public interface OrderRepository {
    Aggregate&lt;Order&gt; findById(String orderId);
    void save(Aggregate&lt;Order&gt; orderAggregate);
    void remove(Aggregate&lt;Order&gt; orderAggregate);
}
</code></pre>
<p>我们再看Service代码示例，先从Repository拿到Aggregate，再取出聚合根Order，调用order的checkout方法完成业务处理，最后调用Repository保存Aggregate.</p>
<pre><code class="language-java">public class OrderService {
    public void checkout(String orderId, CheckoutRequest request) {
        Aggregate&lt;Order&gt; aggregate = orderRepository.findById(orderId);
        Order order = aggregate.getRoot();

        Payment payment = new Payment(request.getAmount());
        order.checkout(payment);

        orderRepository.save(aggregate);
    }
}
</code></pre>
<p>整个方案本质上通过引入一个快照，从而可以对比数据的变化，然后做相应的数据库修改操作。虽然这个方案修改了Repository的接口定义，但是影响范围是有限的，因为这个接口只在Service和Repository之间使用。所以影响范围有限，方案是可行的。</p>
<h3><a id="%E8%81%9A%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E5%B7%A5%E5%85%B7%EF%BC%9Aaggregate-persistence" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>聚合持久化工具：Aggregate-Persistence</h3>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/meixuesong/aggregate-persistence">Aggregate-Persistence</a>  正是基于此方案开发的持久化工具，它非常的轻量，本身不做数据库操作，它做的事情就是帮助你构建这个聚合容器，你可以用它来跟踪状态的变化：</p>
<ul>
<li>识别出哪些属性发生了变化，这样你就可以很容易只修改发生变化的数据库字段，而不是所有字段；</li>
<li>识别出实体集合的变化，例如它能帮你识别出订单聚合中的订单行的增加、修改和删除，因此你做相应的数据库修改操作。</li>
</ul>
<p>同时，它提供了基于Version的乐观锁支持，确保聚合作为一个工作单元整体被持久化。 <a href="https://link.zhihu.com/?target=https%3A//github.com/meixuesong/aggregate-persistence-sample">订单聚合持久化示例</a>  展示了基于Aggregate-Persistence，使用Mybatis实现订单持久化的例子。</p>
<p>该工具经过1年多的不断完善，已经日渐成熟，日前发布了1.2版本，更多详情请访问 <a href="https://link.zhihu.com/?target=https%3A//github.com/meixuesong/aggregate-persistence">Aggregate-Persistence</a> 。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[想要高响应力？你可能缺了重构能力！]]></title>
    <link href="https://xuesong.tech/16980721194925.html"/>
    <updated>2023-10-23T22:41:59+08:00</updated>
    <id>https://xuesong.tech/16980721194925.html</id>
    <content type="html"><![CDATA[
<p>天下武功，唯快不破！在这样一个快速变化的时代，企业也在追求高响应力（快）的路上一路狂奔！这才有了敏捷、DevOps大行其道。然而，很多企业发现，虽然团队号称敏捷了，但是响应力变化并不明显，质量可能还下降了，程序员996加班更严重了。这是敏捷/DevOps转型的锅吗？企业该怎么办？</p>
<span id="more"></span><!-- more -->
<h2><a id="%E5%8D%95%E8%85%BF%E8%B5%B0%E8%B7%AF%E7%9A%84%E6%95%8F%E6%8D%B7%E6%98%AF%E5%81%87%E6%95%8F%E6%8D%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单腿走路的敏捷是假敏捷</h2>
<p><img src="media/16980721194925/16980721423594.jpg" alt="clipboardimage.jpeg" /></p>
<p>敏捷转型常常从管理实践开始，搭起看板，把任务可视化；每天站会；有了迭代计划会和回顾会，迭代运作起来了。然而压力接踵而至。</p>
<p>以前几个月才上一次线，现在两周就要上线，还要留出时间给测试和部署，开发的时间少了。自动化程度严重不足、手工操作效率低、经常出错。测试人员也抱怨测试时间更少了，根本没有办法做必要的回归测试，生产事件开始增多，客户满意度下降。</p>
<p>压力之下，996成为标配，质量成为牺牲品。随着质量下降，生产问题增多，技术骨干开始忙于救火，无暇顾及日常开发质量，导致新代码质量越来越差，形成了质量差、忙于救火、质量更差的恶性循环。</p>
<p>这不是真的敏捷！真的敏捷不仅需要管理实践提升团队协作水平、发现和暴露问题，还需要有效的技术实践解决问题。最重要的是，敏捷不会妥协质量，因为质量是一切的根本。</p>
<h2><a id="%E8%B4%A8%E9%87%8F%E6%98%AF%E4%B8%80%E5%88%87%E7%9A%84%E6%A0%B9%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>质量是一切的根本</h2>
<p><img src="media/16980721194925/16980721423620.jpg" alt="clipboardimage 2.jpeg" /></p>
<p>当团队面临压力时，最容易妥协的就是质量。先不说质量问题导致的业务影响，单看它对团队自身的影响就已经让人震惊了。</p>
<p>为了解决质量问题，团队要消耗大量的时间。问题发现得越早，解决的成本越低。当产品发布后发现问题，成本就更高了。至少要经过发现问题、复现问题、修复问题、验证修复效果、部署上线再验证这么多环节才能把它解决掉。</p>
<p>当团队焦头烂额地解决层出不穷的质量问题时，又会在当前项目的进度压力下继续妥协质量，陷入无法自拔的漩涡。伴随代码质量的下降，会不断积累技术债。当技术债积累到一定程度，系统再也无法支撑新的需求。</p>
<p>残酷的现实是，加人无法解决质量问题，加人只能让团队以更糟糕的质量完成任务。代价就是降低未来的响应力。</p>
<p>要实现高响应力的目标，同时让团队实现可持续的良性运作，就必须将质量放在第一位，而这离不开人员能力的提升。</p>
<h2><a id="%E8%83%BD%E5%8A%9B%E6%98%AF%E7%BB%95%E4%B8%8D%E5%BC%80%E7%9A%84%E9%97%A8%E6%A7%9B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>能力是绕不开的门槛</h2>
<p><img src="media/16980721194925/16980721423651.jpg" alt="clipboardimage 3.jpeg" /></p>
<p>我在很多客户那里看到这样的代码，它们有一个共同的特点：一次性。这些代码是程序员一次性完成的，也只能一次性使用。因为没人能再看得懂，包括作者自己。未来的变更成本将高于重新开发的成本。</p>
<p>对比其它行业，我们也看到软件行业的怪象。很少有人能够一次性把文章写出来就可以发表，人们需要打草稿、修订，不断推敲润色。但代码可以，写出来的草稿读不懂没关系，CPU能读懂就行；同样没有任何一个建筑师可以一遍就把图纸设计出来。但代码可以，一次性写完，只要没被测出Bug，任务就完成了；</p>
<p>这不是程序该有的样子。代码同样是需要打草稿不断推敲的，需要及时优化调整它的结构，确保它不仅运行正确，而且可读性好、易维护。这个叫重构的能力非常重要。缺了重构的能力，团队开发出来的系统刚上线就进入苟延残喘的状态，过不了2-3年就不得不重新开发新系统替换掉它。而具备重构的能力，系统可以持续演进，基业长青。</p>
<p>要想达到程序该有的样子，就必须提升人的能力，如何才能提高人员能力？</p>
<h2><a id="%E9%9D%A2%E5%90%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%83%BD%E5%8A%9B%E8%AF%84%E4%BC%B0%E5%92%8C%E8%AE%A4%E8%AF%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>面向程序员的能力评估和认证</h2>
<p><img src="media/16980721194925/16980721423683.jpg" alt="clipboardimage 4.jpeg" /></p>
<p>管理学大师彼得德鲁克曾经说过“你如果无法度量它，就无法管理它”。对于代码，SonarQube这样的静态代码扫描工具可以在某种程度上度量代码质量。但就像Word的拼写检查功能，它能够识别错别字，却无法告诉你文章写得好不好。</p>
<p>我们需要提前一步，帮助程序员评估和提升自身能力，从而能够自己刻意练习。因此我认为”重构能力评估与认证“是一个好的选择。它不是考卷，不仅仅只考察最终代码，还要考察写代码和重构的过程。它能够：</p>
<ol>
<li>帮助程序员：评估自身能力，找到差距，通过刻意练习提升自我，进而加薪晋爵（认证勋章）。</li>
<li>帮助团队：评估团队成员重构能力，构建人才金字塔，切实提升代码质量。再也不会出现代码走查发现不了问题的状况了！</li>
<li>帮助组织：建立招聘、晋升门槛，管理外包供应商团队，构建质量护城河，实现能力提升、交付质量提升的双赢。</li>
</ol>
<p>欢迎扫码进一步了解“重构能力评估及认证服务”。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] 当我们说“事件驱动”时，我们在说什么？]]></title>
    <link href="https://xuesong.tech/16980408257389.html"/>
    <updated>2023-10-23T14:00:25+08:00</updated>
    <id>https://xuesong.tech/16980408257389.html</id>
    <content type="html"><![CDATA[
<p>这是我为Thoughtworks洞见翻译的<a href="https://insights.thoughtworks.cn/about-event-driven/">当提到“事件驱动”时，我们在说什么？</a>，英文原文：<a href="https://martinfowler.com/articles/201701-event-driven.html">What do you mean by “Event-Driven”?</a></p>
<p>去年年底（译者注：2016年底），我和ThoughtWorks同事一起参加了一个研讨会，讨论“事件驱动”的本质。过去的几年里，我们构建的很多系统都大量使用了事件。对于这些系统，人们常常赞誉有加，但批评的声音也不绝于耳。我们的北美办公室组织了一次峰会，来自世界各地的ThoughtWorks资深开发者出席会议并分享了他们的想法。</p>
<p>这次峰会的最大成果是认识到当人们谈论“事件”时，实际上说的是完全不同的东西，所以我们花了很多时间来梳理一些有用的模式。本文简要总结我们的成果。</p>
<span id="more"></span><!-- more -->
<h2><a id="%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>事件通知</h2>
<p>当领域内有变化发生时，发送事件消息来通知其它系统。事件通知的一个关键点是源系统并不关心外部系统的响应。通常它根本不期待任何结果，即使有也是间接的。 发送事件的逻辑流与响应该事件的逻辑流之间会有显著的隔离。</p>
<p>事件通知非常有用，因为它意味着低耦合，并且结构也非常简单。但是，当逻辑处理流跨越各种事件通知时，它也可能成为问题。因为没有任何代码显式地描述这个流程，所以这个流程是不可见的。通常，唯一的办法是通过监控系统来观察它。这会导致调试和修改流程变得很困难。这里的危险在于，当你使用事件通知来优雅地做系统解耦时，没有意识到更大规模的流程，而这会让你在未来几年中陷入困境。不论如何，此模式仍然非常有用，但你必须小心陷阱。</p>
<p>将事件用作被动操控型命令(Passive-aggressive command)，就是这种陷阱的简单示例。它指的是源系统期待接收方执行一个动作，此时本该使用命令消息(Command message)来展现此意图，然而却使用了事件。</p>
<p>事件不需要包含太多数据，通常只有一些id信息和一个指向发送方、可供查询更多信息的链接。 接收方知道它已发生变化并且接收到关于变化的最少信息，随后会向发送方发出请求，以决定下一步该做什么。</p>
<h2><a id="%E4%BA%8B%E4%BB%B6%E6%90%BA%E5%B8%A6%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%EF%BC%88event-carried-state-transfer%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>事件携带的状态转移（Event-Carried State Transfer）</h2>
<p>采用此模式时，可以在不需要访问源系统的情况下，更新客户端的信息。客户管理系统可能在客户修改自己的详细信息（如地址）时抛出事件，事件包含了详细的修改数据。因此，接收方无需与客户管理系统通信，就可以更新自己的客户数据副本，以进行下一步的操作。</p>
<p>这种模式的一个明显缺点是，有很多冗余数据和副本。但在存储很便宜的时代，这不是一个问题。我们获得了更好的弹性，因为即使客户管理系统不可用时，接收方系统仍然可以正常工作。我们减少了延迟，因为访问客户信息不需要远程调用。我们也不必担心所有来自消费端的查询给客户管理系统带来的负载。但它确实给事件接收端带来了更多复杂性，因为它必须维护所有状态，而如果它直接访问事件发送方查询信息，通常会更加容易。</p>
<h2><a id="%E4%BA%8B%E4%BB%B6%E6%BA%AF%E6%BA%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>事件溯源</h2>
<p>事件溯源(<a href="https://martinfowler.com/eaaDev/EventSourcing.html">Event Sourcing</a>)的核心思想是，每当系统状态发生变化时，都将状态更改记录为事件，这样我们就有信心在任何时间都能够通过重新处理事件来重建系统状态。事件库成为事实的主要来源，系统状态完全来源于它。对于程序员来说，最好的例子就是版本控制系统。所有的提交日志就是事件库，源码树的工作副本是系统状态。</p>
<p>事件溯源引入了很多问题，我不会在这里讨论，但我想强调一些常见的误解。事件处理不必是异步的，以更新本地Git库为例，这完全是一个同步操作，就像更新Subversion这样的集中式版本控制系统一样。当然拥有所有这些提交允许你做各种有趣的事情，Git就是一个很好的例子，但核心提交从根本上说是一个简单的动作。</p>
<p>另一个常见错误是，假定使用事件溯源系统的每个人都应该理解并访问事件日志以确定有用的数据。但实际上很可能对事件日志只具备有限的了解。我正在使用编辑器写这篇文章，编辑器不知道我的源代码树中的所有提交，它只是假设磁盘上有一个文件。在基于事件溯源的系统中，很多处理可以基于一个有效的工作副本。只有当真正需要事件日志中的信息时才必须处理它。如果需要的话，我们可以有多个不同Schema的工作副本，但通常应该在领域处理和通过事件日志派生工作副本之间做明确区分。</p>
<p>使用事件日志时，构建工作副本的快照通常很有用，这样你就不必在每次需要工作副本时都从头开始处理所有事件。实际上这里存在二元性，我们可以将事件日志视为变更列表或状态列表。 我们可以从一个派生出另一个。版本控制系统通常在事件日志中混合快照和增量变更，以获得最佳性能。[<a href="https://martinfowler.com/articles/201701-event-driven.html#footnote-git-snapshot">1</a>]</p>
<p>考虑一下版本控制系统带来的价值，就很容易明白事件溯源有许多有趣的收益。事件日志提供了强大的审计功能（账户交易是帐户余额的事件溯源）。我们可以重放事件日志到某个点来重新创建历史状态。在重放时注入假设事件可以探索不一样的历史。事件溯源使得非持久化的工作副本（例如<a href="https://martinfowler.com/bliki/MemoryImage.html">Memory Image</a>）变得合理可行。</p>
<p>事件溯源也有自己的问题。 当结果依赖于与外部系统的交互时，重放事件就会遇到问题。随着时间的推移，我们必须清楚如何处理事件Schema的变化。许多人发现事件处理给系统增加了很多复杂性（尽管我很想知道，工作副本派生组件和领域处理组件之间糟糕的隔离，是不是更主要的原因）。</p>
<h2><a id="cqrs" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CQRS</h2>
<p>命令查询职责分离（<a href="https://martinfowler.com/bliki/CQRS.html">CQRS</a>）是指读取和写入分别拥有单独的数据结构。 严格地说，CQRS跟事件没有关系，因为你完全不需要任何事件就可以使用CQRS。但通常人们会将CQRS与之前的模式结合起来，因此我们在峰会上就此进行了讨论。</p>
<p>使用CQRS的理由是，在复杂领域中，使用单一模型处理读取和写入过于复杂，我们可以通过分离模型来简化。当访问模式有区别时（例如大量读取和非常少的写入），这一点尤其具有吸引力。但是，需要注意平衡CQRS的收益和分离模型所带来的额外复杂度。我发现很多同事对使用CQRS非常警惕，发现它经常被滥用。</p>
<h2><a id="%E7%90%86%E8%A7%A3%E8%BF%99%E4%BA%9B%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>理解这些模式</h2>
<p>作为一名热衷于收集样本的软件植物学家，我发现这是一个棘手的地带。 核心问题是不同模式的混淆。 在某个项目中，一位能力很强，经验丰富的项目经理告诉我，事件溯源是一场灾难，任何变化都需要两倍的时间来修改读和写模型。 在他这句话中，我可以发现事件溯源和CQRS之间可能存在混淆，我们如何找出哪个是罪魁祸首？ 该项目的技术主管声称主要问题是大量的异步通信，这当然是一个已知的复杂性助推器，但这不是事件溯源或CQRS的必要组成部分。 总的来说，我们必须要注意这些模式在对的地方都很好，反之则很糟糕。 但是当我们混淆了这些模式时，很难弄清楚哪里是对的地方。</p>
<p>我想写一篇论文来梳理清楚所有的混乱，提供强有力的指导，告诉你何时使用，以及如何使用好每一种模式。遗憾的是，我没有那么多时间。 我希望这篇文章有用，但它可能缺少你真正需要的信息。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你值得拥有的一份开发者书单]]></title>
    <link href="https://xuesong.tech/16981081172207.html"/>
    <updated>2023-10-24T08:41:57+08:00</updated>
    <id>https://xuesong.tech/16981081172207.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码整洁之道:程序员的职业素养</h2>
<p>当初冲着Bob大叔的大名，买了这本书。翻开来看却发现没有代码，难道这是一本冲流量送的书？阅读下去，才发现这是一本很朴实的书。读起来很轻松，但话题却很厚重。他告诉你什么是专业精神，如何管理你的时间，如何发展你的职业。我印象最深的是为什么开发者要说“不”，什么时候该说“是”。这本书也许能敲醒996压力下的开发者。</p>
<span id="more"></span><!-- more -->
<h2><a id="%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>测试驱动开发: 实战与模式解析</h2>
<p>测试驱动开发(TDD)是一个很有争议的话题，原因是大家在激烈争论时，争论的其实不是同一个东西。很多开发者不了解TDD是什么，以为TDD的重点是测试。而真正掌握了TDD的开发者才知道，测试只是一个手段，TDD最关键的是任务分解。我不指望大家都来阅读这本书，因为这真的不是一本容易读的书，需要有耐心、毅力和练习。但是如果你想在职业生涯中有所建树，我强烈推荐TDD发明人、敏捷宣言共同缔造者Kent Beck的这本开山之作。因为TDD已经超越了编程本身。不论你是做开发、还是做管理，任务分解都是最核心的基本功。期待你从现在开始就通过TDD来刻意练习这种能让你终生受益的内功。</p>
<h2><a id="%E9%A9%AF%E6%9C%8D%E7%83%82%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>驯服烂代码</h2>
<p>这是我的同事伍斌的著作。他多年来经常组织代码操练道场，因此人称“道长”。这本书是他多年操练的精华。如果你尝够了烂代码的痛苦，期望提升重构技能，却又无从下手，这本书是一个好的开始。书中并没有讲述那么多的理论，更多的是一步步描述驯服过程。因此这本书的打开方式有些特别，如果你只是阅读这本书，那么请你放下它。如果你边阅读边敲着键盘，那恭喜你，你已经走在正确的道路上。</p>
<h2><a id="%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%9A%E5%8E%9F%E5%88%99%E3%80%81%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%AE%9E%E8%B7%B5%EF%BC%88c%E5%92%8C-java%E7%89%88%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>敏捷软件开发：原则、模式与实践（ C#和JAVA版）</h2>
<p>在我从业生涯的早期，非常有幸阅读了这本书，这是Bob大叔的一本经典著作。Bob大叔提出的SOLID原则是软件开发领域最重要的设计原则之一。他在本书中进行了详细描述。除此之外，对于敏捷的初学者，你不仅能了解极限编程的实践，还能清楚敏捷开发模式下如何进行设计。如果你对设计模式感兴趣，也能在书中最后一部分找到常见设计模式的真实应用。强烈推荐所有开发者都阅读本书。</p>
<h2><a id="%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>修改代码的艺术</h2>
<p>什么是遗留系统？作者给出的定义是没有测试覆盖的系统。可以说当今很多系统都是遗留系统。大部分开发者一边饱受烂代码的折磨，一边又在不断炮制出新的烂代码。这些遗留系统的普遍问题是设计不合理，不具备可测试性，因此很难重构。这本书告诉你如何在遗留系统中找到接缝，进行解耦、测试和重构。这就像庖丁解牛一样，对于各种看起来无能为力的耦合，作者一刀一刀地给你展示精彩绝伦的手法，令人叹为观止。建议不要在睡前阅读，否则可能会让你兴奋得无法入睡。</p>
<h2><a id="%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>持续交付</h2>
<p>Jez Humble是前ThoughtWorks首席咨询师。这是软件领域的一本经典著作，并且获得Jolt大奖。虽然原书马上就出版10周年了，但当今软件交付、DevOps的绝大部分实践仍然脱离不了本书的框架。对于软件交付团队的开发者和项目管理者，本书将告诉你如何流畅地发布高质量软件。</p>
<h2><a id="%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B2%BE%E9%AB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>领域驱动设计精髓</h2>
<p>领域驱动设计（DDD）是一种应对复杂系统的经典设计方法，它诞生于面向对象（OO)编程思想，却又超越OO。以至于我的同事函数式编程大师“大魔头”说OO已死，DDD永生。随着微服务架构的兴起，DDD被越来越多的团队重视，然而DDD的高门槛挡住了不少非开发人员。这本书旨在让所有干系人，包括架构师、开发者、业务分析师、领域专家和管理者都能够读懂DDD。它把很多内容进行了精简升华，并解释了很多难以理解的概念。对初学者能够了解DDD的全貌，有经验者也可以阅读本书学习到作者对于一些争议观点的独到看法。</p>
<h2><a id="%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>领域驱动设计模式、原理与实践</h2>
<p>对于开发者来说，如果只读一本领域驱动设计的书，我会强烈推荐这本书。与Eric的蓝皮书原著不同，这本书不仅引入了最新的DDD技术，例如领域事件、事件溯源等，更重要的是，它全面深入地展示了DDD落地方法。如果你想深入学习DDD，并且将它落地为代码，那么你一定要阅读这本书。虽然书中代码以.Net技术为主，但丝毫不影响Java开发者学习。</p>
<h2><a id="sre%EF%BC%9Agoogle%E8%BF%90%E7%BB%B4%E8%A7%A3%E5%AF%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SRE：Google运维解密</h2>
<p>这本书全面介绍了Google如何构建、部署、监控和运维旗下最复杂、最先进的系统。也许你觉得你的系统没有那么大那么复杂，但这不影响你了解其背后的思想，从而完善你的运维体系。在传统企业，我特别推荐其中的一项实践“事后总结：从失败中学习”。很多企业会做生产事故的复盘，然而效果却不理想。这本书会告诉你如何做真正有效的事故复盘、如何制定真正有效的改进措施，以及如何将经验教训传播到更广的范围，避免事故重复发生。</p>
<h2><a id="%E5%8F%91%E5%B8%83%EF%BC%81%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E9%83%A8%E7%BD%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>发布！软件的设计与部署</h2>
<p>这是一本被书名耽误了的杰作。如果改成架构师的自我修养也许能热卖。这本书体系化地讨论了系统的稳定性、容量设计、安全和可用性等话题，它告诉你如何设计工业级的软件。也许部分内容有些过时，但思想却不会过时。在微服务日益盛行的今天，这本书变得更加重要。本书的第2版已经由我的同事“道长”一年前翻译完成，遗憾的是出版社的原因至今未能出版。不论哪个版本，都强烈推荐给各位架构师和开发者。</p>
<h2><a id="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>微服务架构设计模式</h2>
<p>这本书内容很全面，是实践微服务架构的推荐参考书籍。书中列出了很多常见问题及其对应的解决办法，也就是模式。当然因为篇幅的原因，部分章节不是非常的深入。读者可以把相关模式作为一个指南和索引，再挑选自己关心的内容深入研究。总体来说，这是一本非常好的微服务实践指南。我最喜欢其中的SAGA, 和微服务测试部分。</p>
<h2><a id="%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84%E6%94%B9%E5%90%8D%E4%B8%BA%EF%BC%9A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>整洁架构 改名为：架构整洁之道</h2>
<p>这又是Bob大叔的一本力作。他的另一个经典著作《整洁代码》讲了代码如何整洁，而这本讲解架构如何整洁。书中对比了结构化、面向对象和函数式三种编程范式，观点犀利，令人叹服。又重新诠释了SOLID原则，这部分内容在《敏捷软件开发：原则、模式与实践》也有详细论述。架构是组件的连接，因此书中用了大量篇幅讲解组件的设计原则，分而治之的思想，这部分特别烧脑，建议读者组团阅读，围炉夜话，将是人生一大幸事。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[聊一聊聚合的持久化]]></title>
    <link href="https://xuesong.tech/16980608396177.html"/>
    <updated>2023-10-23T19:33:59+08:00</updated>
    <id>https://xuesong.tech/16980608396177.html</id>
    <content type="html"><![CDATA[
<p>本篇文章内容来自 <a href="https://github.com/meixuesong/aggregate-persistence">我的Github项目：Aggregate Persistence</a> Readme文件。</p>
<p>这个项目源于我在做DDD咨询时的一个痛点。我们在做DDD时，不论EventStorming怎么Happy，到最后都会遇到一个痛点：分层架构落地。分层架构本身可以通过讲解和示例帮助团队掌握，但其中聚合的持久化却一直没有发现好的解决方案，写出来的代码自己都不是很满意。所以最后才有了这个项目，也欢迎大家使用并提宝贵建议。</p>
<span id="more"></span><!-- more -->
<blockquote>
<p>DDD-China分享摘要：在DDD实践中，聚合应该作为一个整体进行读取和持久化，以确保业务规则不被破坏。然而现有的持久化技术(如ORM框架、Spring Data等)直接实现聚合持久化，特别是关系型数据库的持久化时，总是面临不少挑战。在本次分享中，我将以实际项目为例，探讨如何实现一种优雅的方案来解决这个问题。</p>
</blockquote>
<h2><a id="1%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 简介</h2>
<p>领域驱动设计(DDD)已经被业界认为是行之有效的复杂问题解决之道。随着微服务的流行，DDD也被更多的团队采纳。然而在DDD落地时，聚合(Aggregate)的持久化一直缺少一种优雅的方式解决。</p>
<p>在DDD实践中，聚合应该作为一个完整的单元进行读取和持久化，以确保业务的不变性或者说业务规则不变破坏。例如，订单总金额应该与订单明细金额之和一致。</p>
<p>由于领域模型和数据库的数据模型可能不一致，并且聚合可能涉及多个实体，因此Hibernate, MyBatis和Spring Data等框架直接用于聚合持久化时，总是面临一些困难，而且代码也不够优雅。有人认为NoSQL是最适合聚合持久化的方案。确实如此，每个聚合实例就是一个文档，NoSQL天然为聚合持久化提供了很好的支持。然而并不是所有系统都适合用NoSQL。当遇到关系型数据库时，一种方式是将领域事件引入持久化过程。也就是在处理业务过程中，聚合抛出领域事件，Repository根据领域事件的不同，执行不同的SQL，完成数据库的修改。但这样的话，Repository层就要引入一些逻辑判断，代码冗余增加了维护成本。</p>
<p>本项目旨在提供一种轻量级聚合持久化方案，帮助开发者真正从业务出发设计领域模型，不需要考虑持久化的事情。在实现Repository持久化时，不需要考虑业务逻辑，只负责聚合的持久化，从而真正做到关注点分离。</p>
<p>方案的核心是<code>Aggregate&lt;T&gt;</code>容器，T是聚合根的类型。Repository以<code>Aggregate&lt;T&gt;</code>为核心，当Repository查询或保存聚合时，返回的不是聚合本身，而是聚合容器<code>Aggregate&lt;T&gt;</code>。以订单付款结账为例，Application Service的代码如下：</p>
<pre><code class="language-java">@Transactional
public void checkout(String orderId, CheckoutRequest request) {
    Aggregate&lt;Order&gt; aggregate = orderRepository.findById(orderId);
    Order order = aggregate.getRoot();

    Payment payment = new Payment(PaymentType.from(request.getPaymentType()), request.getAmount());
    order.checkout(payment);

    orderRepository.save(aggregate);
}
</code></pre>
<p><code>Aggregate&lt;T&gt;</code>保留了聚合的历史快照，因此在Repository保存聚合时，就可以与快照进行对比，找到需要修改的实体和字段，然后完成持久化工作。它提供以下功能：</p>
<ul>
<li><code>public R getRoot()</code>：获取聚合根</li>
<li><code>public R getRootSnapshot()</code>: 获取聚合根的历史快照</li>
<li><code>public boolean isChanged()</code>: 聚合是否发生了变化</li>
<li><code>public boolean isNew()</code>：是否为新的聚合</li>
<li><code>public &lt;T&gt; Collection&lt;T&gt; findNewEntities(Function&lt;R, Collection&lt;T&gt;&gt; getCollection, Predicate&lt;T&gt; isNew)</code>：在实体集合（例如订单的所有订单明细行中）找到新的实体</li>
<li><code>public &lt;T, ID&gt; Collection&lt;T&gt; findChangedEntities(Function&lt;R, Collection&lt;T&gt;&gt; getCollection, Function&lt;T, ID&gt; getId)</code>：在实体集合（例如所有订单明细行中）找到发生变更的实体</li>
<li><code>public &lt;T, ID&gt; Collection&lt;T&gt; findRemovedEntities(Function&lt;R, Collection&lt;T&gt;&gt; getCollection, Function&lt;T, ID&gt; getId)</code>：在实体集合（例如所有订单明细行中）找到已经删除的实体</li>
</ul>
<p>工具类<code>DataObjectUtils</code>提供了对象的对比功能。它可以帮助你修改数据库时只update那些变化了的字段。以Person为例，<code>DataObjectUtils.getDelta(personSnapshot, personCurrent)</code>将返回Delta值。如果属性没有发生变化，Delta的对应属性值为null, 否则为修改后的值。下表展示了这种差别，personCurrent是当前值，personSnapshot是旧值。</p>
<p><img src="media/16980608396177/clipboardimage.jpg" alt="" /><br />
Object | ID | NAME | AGE | ADDRESS | VERSION<br />
—————— |——|——|——|——|——<br />
personCurrent | 001 | Mike | 20 | Beijing | 1<br />
personSnapshot | 001 | Mike | 21 | Shanghai | 1<br />
delta | null | null | 21 | Shanghai | null</p>
<p>与Hibernate的<code>@Version</code>类似，聚合根需要实现Versionable接口，以便Repository基于Version实现乐观锁。Repository对聚合的所有持久化操作，都要判断Version。示意SQL如下：</p>
<pre><code class="language-sql">    insert into person (id, name, age, address, version )
    values (#{id}, #{name}, #{age}, #{address}, 1)

    update person set age = #{age}, address = #{address}, version = version + 1
    where id = #{id} and version = #{version}
    
    delete person
    where id = #{id} and version = #{version}
</code></pre>
<h2><a id="2%E4%BD%BF%E7%94%A8-aggregate-persistence" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 使用Aggregate-Persistence</h2>
<p>在项目中加入以下依赖，就可以使用Aggregate-persistence的功能了：</p>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;com.github.meixuesong&lt;/groupId&gt;
            &lt;artifactId&gt;aggregate-persistence&lt;/artifactId&gt;
            &lt;version&gt;1.0.0&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<h2><a id="3%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. 使用示例</h2>
<p>Aggregate-Persistence本身并不负责持久化工作，它是一个工具，用于识别聚合的变更，例如发现有新增、修改和删除的实体，真正的持久化工作由你的Repository实现。</p>
<p>接下来我们通过<a href="https://github.com/meixuesong/aggregate-persistence-sample">订单聚合持久化项目</a>展示Repository如何利用Aggregate-Persistence的功能，实现订单聚合的持久化。该项目的技术栈使用Springboot, MyBatis。</p>
<p>订单聚合包括两个实体：订单（Order）和订单明细行（OrderItem），其中订单是聚合根：</p>
<pre><code class="language-java">public class Order implements Versionable {
    private String id;
    private Date createTime;
    private Customer customer;
    private List&lt;OrderItem&gt; items;
    private OrderStatus status;
    private BigDecimal totalPrice;
    private BigDecimal totalPayment;
    private int version;
}

public class OrderItem {
    private Long id;
    private Product product;
    private BigDecimal amount;
    private BigDecimal subTotal;
}
</code></pre>
<p>OrderRepository完成订单的持久化工作，主要方法如下：</p>
<pre><code class="language-java">public class OrderRepository {
    Aggregate&lt;Order&gt; findById(String orderId);
    void save(Aggregate&lt;Order&gt; orderAggregate);
    void remove(Aggregate&lt;Order&gt; orderAggregate);
}
</code></pre>
<p>在本例中，OrderRepository需要完成订单的新增、订单项的修改（如购买数量变化或者移除了某个商品）、订单的删除功能。由于领域模型与数据模型不一致，因此保存时，Repository将Domain model(Order)转换成Data object(OrderDO)，然后使用MyBatis完成持久化。查询时，进行反向操作，将Data object转换成Domain model.</p>
<h3><a id="3-1%E6%9F%A5%E8%AF%A2%E8%AE%A2%E5%8D%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.1 查询订单</h3>
<p>下面的代码用于查询订单，并返回<code>Aggregate&lt;Order&gt;</code>。当查询数据库并创建Order聚合后，调用<code>AggregateFactory.createAggregate</code>创建<code>Aggregate&lt;T&gt;</code>对象，在<code>Aggregate&lt;T&gt;</code>内部，它将自动保存Order的快照，以供后续对比。</p>
<pre><code class="language-java">public Aggregate&lt;Order&gt; findById(String id) {
    OrderDO orderDO = orderMapper.selectByPrimaryKey(id);
    if (orderDO == null) {
        throw new EntityNotFoundException(“Order(“ + id + “) not found”);
    }

    Order order = orderDO.toOrder();
    order.setCustomer(customerRepository.findById(orderDO.getCustomerId()));
    order.setItems(getOrderItems(id));

    return AggregateFactory.createAggregate(order);
}
</code></pre>
<h3><a id="3-2%E4%BF%9D%E5%AD%98%E6%96%B0%E5%A2%9E%E8%AE%A2%E5%8D%95%E3%80%81%E4%BF%AE%E6%94%B9%E8%AE%A2%E5%8D%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.2 保存新增订单、修改订单</h3>
<p>使用<code>save</code>接口方法完成订单及订单明细行的新增、修改和删除操作。示例代码如下：</p>
<pre><code class="language-java">void save(Aggregate&lt;Order&gt; orderAggregate) {
    if (orderAggregate.isNew()) {
        //insert order
        Order order = orderAggregate.getRoot();
        orderMapper.insert(new OrderDO(order));
        //insert order items
        List&lt;OrderItemDO&gt; itemDOs = order.getItems().stream()
            .map(item -&gt; new OrderItemDO(order.getId(), item))
            .collect(Collectors.toList());
        orderItemMapper.insertAll(itemDOs);
    } else if (orderAggregate.isChanged()) {
        //update order 
        updateAggregateRoot(orderAggregate);
        //delete the removed order items from DB
        removeOrderItems(orderAggregate);
        //update the changed order items
        updateOrderItems(orderAggregate);
        //insert the new order items into DB
        insertOrderItems(orderAggregate);
    }
}
</code></pre>
<p>上例代码中，当<code>orderAggregate.isNew()</code>为true时，调用MyBatis Mapper插入数据。否则如果聚合已经被修改，则需要更新数据。</p>
<p>首先更新聚合根。领域对象(Order)首先被转换成数据对象（OrderDO），然后DataObjectUtils对比OrderDO的历史版本，得到Delta值，最终调用MyBatis的update selective方法更新到数据库中。代码如下：</p>
<pre><code class="language-java">private void updateAggregateRoot(Aggregate&lt;Order&gt; orderAggregate) {
    //get changed fields and its value
    OrderDO delta = getOrderDODelta(orderAggregate);
    //only update changed fields, avoid update all fields: 
    // e.g. update sales_order set xxx = ?, version = version + 1 where id = ? and version = ?
    if (orderMapper.updateByPrimaryKeySelective(delta) != 1) {
        throw new OptimisticLockException(
            String.format(&quot;Update order (%s) error, it’s not found or changed by another user&quot;, 
                orderAggregate.getRoot().getId())
        );
    }
}

private OrderDO getOrderDODelta(Aggregate&lt;Order&gt; orderAggregate) {
    OrderDO current = new OrderDO(orderAggregate.getRoot());
    OrderDO old = new OrderDO(orderAggregate.getRootSnapshot());
    //compare field by field, if field is not changed, its value is null, otherwise its value is current new value
    OrderDO delta = DataObjectUtils.getDelta(old, current);
    //because id and version are unchanged, their value are null, so set to new value, and then the mapper can update by id and version
    delta.setId(current.getId());
    delta.setVersion(current.getVersion());

    return delta;
}
</code></pre>
<p>对于订单明细行的增删改，都是通过Aggregate找到新增、删除和修改的实体，然后完成数据库操作。代码示例如下：</p>
<pre><code class="language-java">private void removeOrderItems(Aggregate&lt;Order&gt; orderAggregate) {
    Collection&lt;OrderItem&gt; removedEntities = orderAggregate.findRemovedEntities(Order::getItems, OrderItem::getId);
    removedEntities.stream().forEach((item) -&gt; {
        if (orderItemMapper.deleteByPrimaryKey(item.getId()) != 1) {
            throw new OptimisticLockException(
                String.format(&quot;Delete order item (%d) error, it's not found&quot;, item.getId())
            );
        }
    });
}

private void updateOrderItems(Aggregate&lt;Order&gt; orderAggregate) {
    Collection&lt;OrderItem&gt; updatedEntities = orderAggregate.findChangedEntities(Order::getItems, OrderItem::getId);
    updatedEntities.stream().forEach((item) -&gt; {
        if (orderItemMapper.updateByPrimaryKey(new OrderItemDO(orderAggregate.getRoot().getId(), item)) != 1) {
            throw new OptimisticLockException(
                String.format(&quot;Update order item (%d) error, it’s not found&quot;, item.getId())
            );
        }
    });
}

private void insertOrderItems(Aggregate&lt;Order&gt; orderAggregate) {
    //OrderItem.getId()为空表示新增实体
    Collection&lt;OrderItem&gt; newEntities = orderAggregate.findNewEntities(Order::getItems, (item) -&gt; item.getId() == null);
    if (newEntities.size() &gt; 0) {
        List&lt;OrderItemDO&gt; itemDOs = newEntities.stream()
            .map(item -&gt; new OrderItemDO(orderAggregate.getRoot().getId(), item))
            .collect(Collectors.toList());
        orderItemMapper.insertAll(itemDOs);
    }
}
</code></pre>
<p><code>Aggregate&lt;T&gt;</code>提供的<code>findXXXEntities</code>系列方法，都是针对订单明细行这样的实体集合。例如订单明细中，可能增加了商品A，修改了商品B的数量，删除了商品C。<code>findXXXEntities</code>方法用于找出这些变更。第1个参数是函数式接口，用于获取实体集合，以便在此集合中识别新增、修改和删除的实体。第2个参数也是函数式接口，获得实体主键值以找到同一实体进行对比（findRemovedEntities, findChangedEntities）或者判断是否为新的实体（findNewEntities）。</p>
<p>需要提醒的是，当聚合发生变化时，不论聚合根是否发生变化，都应该修改聚合根的版本号，以确保聚合作为一个整体被修改。</p>
<h3><a id="3-3%E5%88%A0%E9%99%A4%E8%AE%A2%E5%8D%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.3 删除订单</h3>
<p>删除订单的同时，需要删除所有订单明细行。</p>
<pre><code class="language-java">public void remove(Aggregate&lt;Order&gt; aggregate) {
    Order order = aggregate.getRoot();
    if (orderMapper.delete(new OrderDO(order)) != 1) {
        throw new OptimisticLockException(
            String.format(“Delete order (%s) error, it’s not found or changed by another user”, order.getId())
        );
    }
    orderItemMapper.deleteByOrderId(order.getId());
}
</code></pre>
<p>完整的示例代码见<a href="https://github.com/meixuesong/aggregate-persistence-sample">订单聚合持久化项目</a></p>
<h2><a id="4%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. 总结</h2>
<p>总的来说，本项目提供了一种轻量级聚合持久化方案，能够帮助开发者设计干净的领域模型的同时，很好地支持Repository做持久化工作。通过持有聚合根的快照，<code>Aggregate&lt;T&gt;</code>可以识别聚合发生了哪些变化，然后Repository使用基于Version的乐观锁和DataObjectUtils在字段属性级别的比较功能，实现按需更新数据库。</p>
<h2><a id="%E5%8F%8D%E9%A6%88%E6%94%B6%E9%9B%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>反馈收集</h2>
<p>战菲：</p>
<ul>
<li>Repo.save时，会先查询一遍聚合，然后手工对比得出差异，再用jooq完成数据修改。</li>
<li>没有version，部分地方使用select for update悲观锁。如果没有使用悲观锁的情况下，可能会出现覆盖其他用户的修改。（例如查询后保存前，其他用户又修改了数据）</li>
<li>主要问题：
<ul>
<li>查2遍</li>
<li>手工对比，代码太乱</li>
<li>没有处理并发修改的问题</li>
</ul>
</li>
<li>Aggregate-Persistence能够解决上述3个主要问题</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[以提升员工绩效为目标，打造完美培训]]></title>
    <link href="https://xuesong.tech/16980644116144.html"/>
    <updated>2023-10-23T20:33:31+08:00</updated>
    <id>https://xuesong.tech/16980644116144.html</id>
    <content type="html"><![CDATA[
<p>培训是企业提升员工能力最常见的方式，对于转型期的企业来说更是如此。管理层希望通过培训导入理念、普及知识，从而推动转型。然而一个残酷的事实是，大部分培训其实并没有什么用。我的同事仝校长在他的博客<a href="http://insights.thoughtworkers.org/training-is-useless/">然而培训并没有什么用</a>中表达了相同的观点。他认为培训只在两种情况下有用。一是学员已经充分准备好的情况下，遇到同样充分准备好的内容时。二是培训相当于在心里埋下一颗种子，在培训之后能够不断学习和实践，从而达到培训效果。然而这两种情况对老师和学员来说，似乎都可遇而不可求。</p>
<p>那么企业究竟需要什么样的培训？什么样的培训算是成功？作为一名咨询师和教练，如何做一次成功的培训呢？</p>
<span id="more"></span><!-- more -->
<p>我认为，企业培训的目标是提升员工绩效，只有达到这个目标才算是成功的培训。要实现这个目标就需要将培训视作一个持续的过程，而不只是短短数天的集中“培训”。教练要以终为始去设计课程和流程体验，帮助员工播下“我能改变”和“我想改变”的种子，同时指导企业“松土”和“施肥”，建立合适的环境与机制。通过培养+训战的方式，利用改进形建立闭环，最终实现将培训转化成员工绩效的目的。</p>
<h2><a id="%E5%9F%B9%E8%AE%AD%E7%9A%84%E7%9B%AE%E6%A0%87%E6%98%AF%E6%8F%90%E5%8D%87%E5%91%98%E5%B7%A5%E7%BB%A9%E6%95%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>培训的目标是提升员工绩效</h2>
<p>当我在《将培训转化为商业结果》中读到“培训的目标是提升员工绩效”时，我深以为然。没有企业会支付大量金钱和员工的时间，仅仅为了培训而培训。通过培训提升员工能力，提升其绩效，企业通过员工绩效的提升而获益，这是企业做培训的根本原因。</p>
<p>这个道理很简单，但做起来难，很多时候都变成为了培训而培训。很多企业的人力资源部负责员工培训，每年制定培训计划，联系培训机构和讲师，安排培训，培训结束意味着任务结束。然而培训能起到多大效果，很少或者很难有跟踪和评估。</p>
<p>要想培训有效果，我们就要回到它的目标。如果培训的目标是提升员工绩效，如何才能达成这个目标？</p>
<h2><a id="%E5%9F%B9%E8%AE%AD%E6%98%AF%E4%B8%80%E4%B8%AA%E6%8C%81%E7%BB%AD%E7%9A%84%E8%BF%87%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>培训是一个持续的过程</h2>
<p>为了达成培训目标，就不能把培训看成是一个为期数天的学习活动，而是应该包括前期的准备、学习（培养）、后期知识转化（训战）的完整过程。每一个环节都非常重要，如果做不到位都会影响到最终结果。</p>
<p><img src="media/16980644116144/58BF18C9-76EA-45B2-955F-580B45251F45.png" alt="" /></p>
<p>在准备阶段，要明确目标。企业希望通过培训，解决什么问题？这是一个需要被解决的问题吗？培训是正确的解决方案吗？希望通过培训提升员工哪些方面的绩效。只有明确了“病症”，才有可能下对“处方”，否则吃再多“药”也没有用。</p>
<p>学习阶段，这个阶段做的事情就是传统的“培训”，把它定位成培育种子。这个阶段通常包括让学员学习他不知道的(Know unknown)、强化他已经知道的并初步建立知识体系，更重要的是帮助学员建立“我能改变”和“我想改变”的信念。只有建立了这样的信念，才有可能在后期将知识转化成绩效。</p>
<p>在后期知识转化阶段需要“训战”，包括训练和实战。光学不练是假把式，没有哪个运动员掌握了动作要领就能拿冠军，没有哪个人会读五线谱就能成为音乐家，也没有哪个程序员知道Java语法就能写出好程序。知识要转化成能力和绩效，就需要不断的练习和实战。</p>
<p>因此，培训是为了提升员工绩效，进而推动企业绩效。成功的培训包括前期准备、培养和训战，是一个持续过程。培训的知识不应该只停留在脑中，而是应该转化成绩效。</p>
<p>作为咨询师和教练，如何打造这样的培训？</p>
<h2><a id="%E4%BB%A5%E7%BB%88%E4%B8%BA%E5%A7%8B%E8%AE%BE%E8%AE%A1%E5%9F%B9%E8%AE%AD%E8%BF%87%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>以终为始设计培训过程</h2>
<p>整个培训的过程应该以终为始。当企业提出培训需求时，你需要了解背景是什么？并且把关注点从如何培训转移到要解决的业务问题或者机遇是什么？在课程设计、培养和训战流程设计时，都应该围绕目标进行。</p>
<p>管理层对目标的认同和对自己角色的定位是确保培训效果的重要因素。很多时候管理层是不清楚目标的，教练要通过沟通和引导帮助管理层明确目标，确保他们清楚培训与员工绩效和业务目标的关系。同时管理层与培训并不是孤立的关系，他们也承担了一定的职责。例如，如何激励员工，如何创造环境让学员学以致用。</p>
<p>学员带着清晰的目标和实际问题参加培训效果更佳。清晰的目标会促进学员主动思考。对成年人来说，当培训与实际问题有明确的关联性时，能够极大增强学习动机。因此要让学员带着目标和问题来参加培训。培训前的高层领导讲话和动员是应对这种情况的一个非常好的实践。</p>
<p>培训课程应该与学员当前能力匹配。课程难度过高或过低都不利于培训效果，因此应该提前摸清学员状况。通过调查问卷、访谈等方式了解学员的背景和现状，在实际工作中有哪些困难和挑战。然后从现状出发，以目标为终点，识别出培训需求，从而完成课程设计和日程安排。</p>
<h2><a id="%E6%92%AD%E4%B8%8B%E2%80%9C%E6%88%91%E8%83%BD%E6%94%B9%E5%8F%98%E2%80%9D%E5%92%8C%E2%80%9C%E6%88%91%E6%83%B3%E6%94%B9%E5%8F%98%E2%80%9D%E7%9A%84%E7%A7%8D%E5%AD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>播下“我能改变”和“我想改变”的种子</h2>
<p>在培养阶段，也就是集中学习的阶段，是教练们很熟悉和擅长的阶段。需要注意的是，在这个阶段最重要的不是学员学到更多东西，而是播下“我能改变”和“我想改变”的种子。培训不是重点，结果才是重点。只有今天播下了种子，明天才能发芽和成长。</p>
<p><img src="media/16980644116144/clipboardimage.jpg" alt="" /></p>
<h3><a id="%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BA%94%E4%B8%AA%E5%8E%9F%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>课程设计的五个原则</h3>
<p>以下五个原则有利于帮助学员做到“我能改变”和“我想改变”：</p>
<p><strong>少即是多</strong>：课程内容不宜太多太满，因为这样会给学员产生过大的压力，一方面学员不容易聚焦，另一方面畏难情绪就会滋长，抑制了学习积极性和创造性思维。因此课程要聚焦、留白，让学员有时间消化和思考，与实际问题联系起来。</p>
<p><strong>婴儿步</strong>：这个极限编程的原则同样适用于培训。通过小步前进，可以不断增强学员信心。这就要求课程的设计也要做任务分解，每个任务的职责尽量单一。</p>
<p><strong>正反馈</strong>：情绪对学习有强大的直接影响，在交互过程中，尽量以正反馈为主。正向的反馈能够调动大家的积极性，对于营造轻松、积极的学习氛围非常有帮助。即使是学员间的互动，也尽量以正反馈为主。我曾经有一次组织学员分组PK，如果A组找到B组的问题，A组加分，并且B组扣分。事后分析，B组扣分这样的规则并不好，让现场的气氛发生微妙的变化。</p>
<p><strong>同理心</strong>：整个培训是一个持续的过程，在这个过程中，教练要有同理心。站在学员的角度思考、体验和检查整个过程。提升用户体验，确保用户体验是完整的、一致的。这就要求课程应该是充分准备，哪里需要思考、练习、辩论、高潮，都是设计好的。</p>
<p><strong>自主觉察</strong>：“觉察”这个词很有意思，我第一次理解它是在《高绩效教练》这本书中。与填鸭式教学不同，教练应该让学员自己觉察哪里对，哪里不对，为什么要这样做。当学员能够自己觉察时，才算是真正理解，才有可能自己去改进。例如测试驱动开发（TDD）是一个比较难的课程，往往学员争议比较多。我在培训时，不会讲太多理论，而是让学员自己觉察。我的做法是让学员自己先做题，然后我展示用TDD的方式做题。让学员自己讨论总结什么是TDD（What），与自己的开发方式有什么不同(How)，有什么好处（Why）以及如何练习（Plan）。采用这种方式，我很少遇到对TDD很抗拒的学员。</p>
<p>在培训中运用好这五个原则，基本上学员就已经初步知道培训内容将如何帮助他解决问题，树立了“我能改变”的信心。然而，从“我能”到“我想”还有一个鸿沟。训战计划就是用来帮助学员跨越这个鸿沟的。</p>
<h3><a id="%E8%AE%AD%E6%88%98%E8%AE%A1%E5%88%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>训战计划</h3>
<p>训战包括训练与实战。训战计划是指学员以小组为单位，通过训练来强化学习内容，并在工作中进行实战的计划。训战计划会在集中学习结束时，由学员自己制定。这是将知识转化成员工绩效的关键一环，甚至可以说，整个集中学习过程都是为了制定这个训战计划。</p>
<p>将知识转换成个人绩效的过程需要自我改变。心理学家詹姆斯·普鲁查斯卡（James Prochaska）和卡洛· 迪克勒蒙特（Carlo DiClemente）在20世纪80年代的共同研究成果表明，自我改变从来不是戏剧性的觉悟和突变，而是有一系列必经步骤的。具体来说，在彻底完成改变、建立新习惯之前，需要经历五个阶段：</p>
<ol>
<li>无意识阶段（Precontemplation）：没有感到问题的存在，或拒绝承认问题的严重性</li>
<li>有意识阶段（Contemplation）：意识到改变的必要性</li>
<li>准备阶段（Preparation）：了解相关步骤，做事前准备</li>
<li>行动阶段（Action）：开始执行计划</li>
<li>维持阶段（Maintenance）：根据新情况进行调整，并继续执行计划</li>
</ol>
<p>跳过任何一个阶段，整个过程都会失败。改变是很难的，在任何一个阶段，学员都可能回到其原始状态。经过了培养阶段的集中学习后，学员已经完成了前2个阶段。接下来的准备阶段是最容易被忽视，也最容易出问题的阶段。此时如果改变意愿不强，就不会有后面的行动。而如果完全没有准备就开始行动，将会快速产生挫败感，导致整个过程失败。</p>
<p><img src="media/16980644116144/440A27C3-6AA9-439F-BA1C-ABD31875AD0D.png" alt="" /></p>
<p>训战计划能够推学员一把，在已经有了改变意识的基础上，利用同侪压力和组织措施将改变意识变成一个行动计划。教练的职责是确保学员的计划符合SMART原则。</p>
<p>制定训战计划的过程一定要有领导的参与。一是学员将更加重视这个计划；二是领导能够指导计划与实际工作相结合；三是领导认可的计划更容易在后续执行阶段得到支持。</p>
<p>制定训战计划的过程，就是学员思考如何将所学应用到工作中的过程。这个过程通常比较耗时，也比较烧脑。有2个方法可以降低这个过程的难度。一是在学习过程中，不断引导学员总结知识点，教练要引导和补充这些知识点和工具箱，并将其可视化；二是使用模板来引导学员制定计划的内容。我的同事总结了一个非常好的模板：</p>
<blockquote>
<p><strong>针对</strong> &lt;知识点、实践、待验证的疑惑&gt;<br />
<strong>我计划在</strong> &lt;截止时间&gt; <strong>之前</strong><br />
<strong>完成</strong> &lt;具体的事情（比如项目优化、尝试新的实践、Session分享，输出Workshop等）&gt;<br />
<strong>验收标准是</strong> &lt;具体可操作的验收标准&gt;</p>
</blockquote>
<h2><a id="%E5%9C%A8%E7%BB%84%E7%BB%87%E5%B1%82%E9%9D%A2%E2%80%9C%E6%9D%BE%E5%9C%9F%E2%80%9D%E5%92%8C%E2%80%9C%E6%96%BD%E8%82%A5%E2%80%9D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在组织层面“松土”和“施肥”</h2>
<p>将培训转化成员工绩效离不开组织的支持。一方面需要“松土”，在组织层面提供相对宽松一些的环境为学员的改进提供支持。例如增加技术债偿还的时间、提供试点项目、鼓励变革与创新等。另一方面需要“施肥”，对做得好的个人和团队进行鼓励和嘉奖，并以点带面扩大战果。</p>
<p>需要提醒的是，要特别重视学员直接上级领导的认同和支持，因为他们是与学员直接接触的工作对象。某种程度来说，他们的支持比高层领导更加重要。直接上级领导一句“你们学的这个挺好，就是在咱们项目不适用”，就会让培训成果打水漂。</p>
<p>因此，作为教练要与相关干系人做好充分的沟通。除了确保前期的目标统一外，还要就培养方式、训战计划的制定和实施进行充分说明，明确各环节他们所起的作用。例如：</p>
<ul>
<li>在培训启动时，领导讲话要说明培训的目标和训战计划，让学员有清楚的目标并带着任务来学习。</li>
<li>在制定训战计划时，领导要给予指导和点评。</li>
<li>在实施训战计划时，领导要提供相应的支持，包括松土和施肥等。</li>
</ul>
<h2><a id="%E5%88%A9%E7%94%A8%E6%94%B9%E8%BF%9B%E5%BD%A2%E5%BB%BA%E7%AB%8B%E9%97%AD%E7%8E%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>利用改进形建立闭环</h2>
<p>培训是一个过程，从现状到目标并不是一蹴而就的。因此训战计划的实施也需要不断迭代。改进形可以帮助建立闭环，持续迭代。</p>
<p>改进形（Improvement Kata）源自丰田，在《丰田套路》中，作者描述了改进形的运作过程：</p>
<ol>
<li>先思考愿景、 方向和目标；</li>
<li>第一手地掌握现状；</li>
<li>朝着既定的愿景方向，设定下 一个目标状态；</li>
<li>然后，我们就能够一步一步地努力往目标状态迈进， 中间遇到的障碍就是我们需要做的事情，我们也可以从中汲取教训</li>
</ol>
<p>下图是改进形的示例模板。我的同事伍斌在他的博客[改进形：专治“没空做改进” - 简书]</p>
<p><img src="media/16980644116144/clipboardimage%202.jpg" alt="clipboardimage 2" /></p>
<p>改进形除了由教练与学员一起做外，也可以由学员之间1对1做。改进形的关键在于小目标的周期要短，最好是1周，目标不要过高，一定要可以执行。这也是俗话说的“不怕慢，就怕站”。</p>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>业界一个公认的事实是培训的转化率非常低，坊间也有很多培训无用论，那么培训究竟应该怎么做？本文提出打造完美培训的观点，但显然培训是不可能完美的。然而如果它能够达到提升员工绩效的目标，我认为它就接近完美了，甚至是不是完美已经不重要了。</p>
<p>本文提出的方法是：以“提升员工绩效”为目标，将培训看成一个持续的过程（包含培养和训战），利用五个课程设计原则和一个训战计划帮助学员建立“我能改变“和”我想改变”的信心，然后在组织层面进行“松土“和”施肥”以构建适合改进的环境，最后通过“改进形”形成闭环指导学员持续改进。</p>
<h2><a id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考文献</h2>
<ol>
<li><a href="http://insights.thoughtworkers.org/training-is-useless/">然而培训并没有什么用</a></li>
<li><a href="https://book.douban.com/subject/30604273/">将培训转化为商业结果：学习发展项目的6Ds法则（第3版） (豆瓣)</a></li>
<li><a href="https://book.douban.com/subject/27046045/">丰田套路：转变我们对领导力与管理的认知（珍藏版） (豆瓣)</a></li>
<li><a href="https://book.douban.com/subject/21264215/">高绩效教练 (豆瓣)</a></li>
<li><a href="https://www.jianshu.com/p/32f0e8a4adbd">改进形：专治“没空做改进” - 简书</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写了这么多年代码，你真的了解SOLID吗？]]></title>
    <link href="https://xuesong.tech/16980614178175.html"/>
    <updated>2023-10-23T19:43:37+08:00</updated>
    <id>https://xuesong.tech/16980614178175.html</id>
    <content type="html"><![CDATA[
<p>尽管大家都认为SOLID是非常重要的设计原则，并且对每一条原则都耳熟能详，但我发现大部分开发者并没有真正理解。要获得最大收益，就必须理解它们之间的关系，并综合应用所有这些原则。只有把SOLID作为一个整体，才可能构建出坚实(Solid)的软件。遗憾的是，我们看到的书籍和文章都在罗列每个原则，没有把它们作为一个整体来看，甚至提出SOLID原则的Bob大叔也没能讲透彻。因此我尝试介绍一下我的理解。</p>
<span id="more"></span><!-- more -->
<p>先抛出我的观点: 单一职责是所有设计原则的基础，开闭原则是设计的终极目标。里氏替换原则强调的是子类替换父类后程序运行时的正确性，它用来帮助实现开闭原则。而接口隔离原则用来帮助实现里氏替换原则，同时它也体现了单一职责。依赖倒置原则是过程式编程与OO编程的分水岭，同时它也被用来指导接口隔离原则。关系如下图：</p>
<p><img src="media/16980614178175/B0F2C958-5A73-44CB-A9E0-E30888C7F505.png" alt="" /></p>
<h2><a id="%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99single-responsibility-principle" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单一职责原则(Single Responsibility Principle)</h2>
<p>单一职责是最容易理解的设计原则，但也是被违反得最多的设计原则之一。</p>
<p>要真正理解并正确运用单一职责原则，并没有那么容易。单一职责就跟“盐少许”一样，不好把握。Robert C. Martin（又名“Bob大叔”）把职责定义为变化原因，将单一职责描述为 ”A class should have only one reason to change.&quot; 也就是说，如果有多种变化原因导致一个类要修改，那么这个类就违反了单一职责原则。那么问题来了，什么是“变化原因”呢？</p>
<p>利益相关者角色是一个重要的变化原因，不同的角色会有不同的需求，从而产生不同的变化原因。作为居民，家用的电线是普通的220V电线，而对电网建设者，使用的是高压电线。用一个Wire类同时服务于两类角色，通常意味着坏味道。</p>
<p>变更频率是另一个值得考虑的变化原因。即使对同一类角色，需求变更的频率也会存在差异。最典型的例子是业务处理的需求比较稳定，而业务展示的需求更容易发生变更，毕竟人总是喜新厌旧的。因此这两类需求通常要在不同的类中实现。</p>
<p>单一职责原则某种程度上说是在分离关注点。分离不同角色的关注点，分离不同时间的关注点。</p>
<p>在实践中，怎么运用单一职责原则呢？什么时候要拆分，什么时候要合并？我们看看新厨师在学炒菜时，是如何掌握“盐少许”的。他会不断地品尝，直到味道刚好为止。写代码也一样，你需要识别需求变化的信号，不断“品尝”你的代码，当“味道”不够好时，持续重构，直到“味道”刚刚好。</p>
<h2><a id="%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99open-closed-principle" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>开闭原则(Open-closed Principle)</h2>
<p>开闭原则指软件实体（类、模块等）应当对扩展开放，对修改闭合。这听起来似乎很不合理，不能修改，只能扩展？那我怎么写代码？</p>
<p>我们先看看为什么要有开闭原则。假设你是一名成功的开源类库作者，很多开发者使用你的类库。如果某天你要扩展功能，只能通过修改某些代码完成，结果导致类库的使用者都需要修改代码。更可怕的是，他们被迫修改了代码后，又可能造成别的依赖者也被迫修改代码。这种场景绝对是一场灾难。</p>
<p>如果你的设计是满足开闭原则的，那就完全是另一种场景。你可以通过扩展，而不是修改来改变软件的行为，将对依赖方的影响降到最低。</p>
<p>这不正是设计的终极目标吗？解耦、高内聚、低耦合等等设计原则最终不都是为了这个目标吗？畅想一下，类、模块、服务都不需要修改，而是通过扩展就能够改变其行为。就像计算机一样，组件可以轻松扩展。硬盘太小？直接换个大的，显示器不够大的？来个8K的怎么样？</p>
<p>什么时候应该应用开闭原则，怎么做到呢？没有人能够在一开始就识别出所有扩展点，也不可能在所有地方都预留出扩展点，这么做的成本是不可接受的。因此一定是由需求变化驱动。如果你有领域专家的支持，他可以帮你识别出变化点。否则，你应该在变化发生时来做决策，因为在没有任何依据时做过多预先设计违反了<a href="https://martinfowler.com/bliki/Yagni.html">Yagni</a>。</p>
<p>实现开闭原则的关键是抽象。在<a href="https://en.wikipedia.org/wiki/Bertrand_Meyer">Bertrand Meyer</a>提出开闭原则的年代（上世纪80年代），在类库中增加属性或方法，都不可避免地要修改依赖此类库的代码。这显然导致软件很难维护，因此他强调的是要允许通过继承来扩展类。随着技术发展，我们有了更多的方法来实现开闭原则，包括接口、抽象类、策略模式等。</p>
<p>我们也许永远都无法完全做到开闭原则，但不妨碍它是设计的终极目标。SOLID的其它原则都直接或间接为开闭原则服务，例如接下来要介绍的里氏替换原则。</p>
<h2><a id="%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99the-liskov-substitution-principle" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>里氏替换原则 (The Liskov Substitution Principle)</h2>
<p>里氏替换原则说的是派生类（子类）对象能够替换其基类（父类）对象被使用。学过OO的同学都知道，子类本来就可以替换父类，为什么还要里氏替换原则呢？这里强调的不是编译错误，而是程序运行时的正确性。</p>
<p>程序运行的正确性通常可以分为两类。一类是不能出现运行时异常，最典型的是UnsupportedOperationException，也就是子类不支持父类的方法。第二类是业务的正确性，这取决于业务上下文。</p>
<p>下例中，由于java.sql.Date不支持父类的toInstance方法，当父类被它替换时，程序无法正常运行，破坏了父类与调用方的契约，因此违反了里氏替换原则。</p>
<pre><code class="language-java">package java.sql;

public class Date extends java.util.Date {
    @Override
    public Instant toInstant() {
        throw new java.lang.UnsupportedOperationException();
    }
}
</code></pre>
<p>接下来我们看破坏业务正确性的例子，最典型的例子就是Bob大叔在《敏捷软件开发：原则、模式与实践》中讲到的正方形继承矩形的例子了。从一般意义来看，正方形是一种矩形，但这种继承关系破坏了业务的正确性。</p>
<pre><code class="language-java">public class Rectangle {
    double width;
    double height;

    public double area() {
        return width * height;
    }
}

public class Square extends Rectangle {
    public void setWidth(double width) {
        this.width = width;
        this.height = width;
    }

    public void setHeight(double height) {
        this.height = width;
        this.width = width;
    }
}

public void testArea(Rectangle r) {
	r.setWidth(5);
	r.setHeight(4);
	assert(r.area() == 20); //! 如果r是一个正方形，则面积为16
}
</code></pre>
<p>代码中testArea方法的参数如果是正方形，则面积是16，而不是期望的20，所以结果显然不正确了。</p>
<p>如果你的设计满足里氏替换原则，那么子类（或接口的实现类）就可以保证正确性的前提下替换父类（或接口），改变系统的行为，从而实现扩展。<a href="https://martinfowler.com/bliki/BranchByAbstraction.html">BranchByAbstraction</a>和<a href="https://www.martinfowler.com/bliki/StranglerApplication.html">绞杀者模式</a> 都是基于里氏替换原则，实现系统扩展和演进。这也就是对修改封闭，对扩展开放，因此<strong>里氏替换原则是实现开闭原则的一种解决方案</strong>。</p>
<p><strong>而为了达成里氏替换原则，你需要接口隔离原则。</strong></p>
<h2><a id="%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99interface-segregation-principle" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口隔离原则 (Interface Segregation Principle)</h2>
<p>接口隔离原则说的是客户端不应该被迫依赖于它不使用的方法。简单来说就是更小和更具体的瘦接口比庞大臃肿的胖接口好。</p>
<p>胖接口的职责过多，很容易违反单一职责原则，也会导致实现类不得不抛出UnsupportedOperationException这样的异常，违反里氏替换原则。因此，应该将接口设计得更瘦。</p>
<p>怎么给接口减肥呢？接口之所以存在，是为了解耦。开发者常常有一个错误的认知，以为是实现类需要接口。其实是消费者需要接口，实现类只是提供服务，因此应该由消费者（客户端）来定义接口。理解了这一点，才能正确地站在消费者的角度定义<a href="https://www.martinfowler.com/bliki/RoleInterface.html">Role interface</a>，而不是从实现类中提取<a href="https://www.martinfowler.com/bliki/HeaderInterface.html">Header Interface</a>。</p>
<p>什么是Role interface? 举个例子，砖头(Brick)可以被建筑工人用来盖房子，也可以被用来正当防卫：</p>
<pre><code class="language-java">public class Brick {
    private int length;
    private int width;
    private int height;
    private int weight;

    public void build() {
        //...包工队盖房
    }

    public void defense() {
        //...正当防卫
    }
}
</code></pre>
<p>如果直接提取以下接口，这就是Header Interface：</p>
<pre><code class="language-java">public interface BrickInterface {
    void buildHouse();
    void defense();
}
</code></pre>
<p>普通大众需要的是可以防卫的武器，并不需要用砖盖房子。当普通大众(Person)被迫依赖了自己不需要的接口方法时，就违反接口隔离原则。正确的做法是站在消费者的角度，抽象出Role interface:</p>
<pre><code class="language-java">public interface BuildHouse {
    void build();
}

public interface StrickCompetence {
    void defense();
}

public class Brick implement BuildHouse, StrickCompetence {
}
</code></pre>
<p>有了Role interface，作为消费者的普通大众和建筑工人就可以分别消费自己的接口：</p>
<pre><code class="language-java">//Worker.java
brick.build();

//Person.java
brick.strike();
</code></pre>
<p><strong>接口隔离原则本质上也是单一职责原则的体现，同时它也服务于里氏替换原则</strong>。而接下来介绍的依赖倒置原则可以用来指导接口隔离原则的实现。</p>
<h2><a id="%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99dependence-inversion-principle" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>依赖倒置原则 (Dependence Inversion Principle)</h2>
<p>依赖倒置原则说的是高层模块不应该依赖底层模块，两者都应该依赖其抽象。</p>
<p><strong>这个原则其实是在指导如何实现接口隔离原则</strong>，也就是前文提到的，高层的消费者不应该依赖于具体实现，应该由消费者定义并依赖于Role interface，底层的具体实现也依赖于Role interface，因为它要实现此接口。</p>
<p>依赖倒置原则是区分过程式编程和面向对象编程的分水岭。过程式编程的依赖没有倒置，<a href="https://flylib.com/books/en/4.444.1.71/1/">A Simple DIP Example | Agile Principles, Patterns, and Practices in C#</a>这篇文章以开关和灯的例子很好地说明了这一点。</p>
<p><img src="media/16980614178175/4D292D2B-986A-4B81-A368-75581ACD443B.png" alt="" /></p>
<p>上图的关系中，当Button直接调用灯的开和关时，Button就依赖于灯了。其代码完全是过程式编程：</p>
<pre><code class="language-java">public class Button {   
    private Lamp lamp;   
    public void Poll()   {
        if (/*some condition*/)
           lamp.TurnOn();   
    } 
}
</code></pre>
<p>如果Button还想控制电视机，微波炉怎么办？应对这种变化的办法就是抽象，抽象出Role interface ButtonServer:</p>
<p><img src="media/16980614178175/78EEBFDF-D669-498A-AF9F-60B3EB98B1DD.png" alt="" /></p>
<p>不管是电灯，还是电视机，只要实现了ButtonServer，Button都可以控制。这是面向对象的编程方式。</p>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>总的来说，单独应用SOLID的某一个原则并不能让收益最大化。应该把它作为一个整体来理解和应用，从而更好地指导你的软件设计。单一职责是所有设计原则的基础，开闭原则是设计的终极目标。里氏替换原则强调的是子类替换父类后程序运行时的正确性，它用来帮助实现开闭原则。而接口隔离原则用来帮助实现里氏替换原则，同时它也体现了单一职责。依赖倒置原则是过程式编程与OO编程的分水岭，同时它也被用来指导接口隔离原则。</p>

]]></content>
  </entry>
  
</feed>
